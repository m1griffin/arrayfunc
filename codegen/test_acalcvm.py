#!/usr/bin/env python3
##############################################################################
# Project:  arrayfunc
# Module:   test_acalcvm.py
# Purpose:  arrayfunc unit test.
# Language: Python 3.4
# Date:     28-Jan-2016.
# Ver:      24-Sep-2017.
#
###############################################################################
#
#   Copyright 2014 - 2017    Michael Griffin    <m12.griffin@gmail.com>
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
##############################################################################
"""This conducts unit tests for acalc.
"""

##############################################################################
import array
import itertools
import math
import operator
import platform

import unittest

import arrayfunc

##############################################################################

##############################################################################

# The following code is all auto-generated.



##############################################################################
# The maximum values for selected array types.
IPLims = {'B' : arrayfunc.arraylimits.B_max , 'H' : arrayfunc.arraylimits.H_max, 
			'I' : arrayfunc.arraylimits.I_max, 'L' : arrayfunc.arraylimits.L_max, 
			'f' : arrayfunc.arraylimits.f_max, 'd' : arrayfunc.arraylimits.d_max}

# Add 'Q' arrays if this is supported on this platform.
if 'Q' in array.typecodes:
	IPLims['Q'] = arrayfunc.arraylimits.Q_max

def InvertPy(typecode, val):
	"""This allows for the invert operation to handle both signed and 
	unsigned integers.
	"""
	# Python native integers are signed.
	if typecode in ('b', 'h', 'i', 'l', 'q'):
		return ~val
	# Unsigned integers require more work to invert.
	else:
		maxval = IPLims[typecode]
		if val >= 0:
			return maxval - val
		else:
			return maxval + val


##############################################################################

##############################################################################
class acalcvm_operator_b(unittest.TestCase):
	"""Test for basic operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'b'


	########################################################
	def test_operator_add_1_acalcvm(self):
		"""Test acalcvm add  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat(-25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat(-25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat(-25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat(-25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_2_acalcvm(self):
		"""Test acalcvm add  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_3_acalcvm(self):
		"""Test acalcvm add  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_4_acalcvm(self):
		"""Test acalcvm add  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_4_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_4_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_4_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_5_acalcvm(self):
		"""Test acalcvm add  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_5_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_5_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_5_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_1_acalcvm(self):
		"""Test acalcvm sub  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_2_acalcvm(self):
		"""Test acalcvm sub  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_3_acalcvm(self):
		"""Test acalcvm sub  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_4_acalcvm(self):
		"""Test acalcvm sub  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_4_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_4_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_4_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_5_acalcvm(self):
		"""Test acalcvm sub  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_5_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_5_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_5_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_1_acalcvm(self):
		"""Test acalcvm mult  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat(-3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat(-3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat(-3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat(-3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_2_acalcvm(self):
		"""Test acalcvm mult  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( -2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( -2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( -2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( -2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_3_acalcvm(self):
		"""Test acalcvm mult  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_4_acalcvm(self):
		"""Test acalcvm mult  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_5_acalcvm(self):
		"""Test acalcvm mult  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_5_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_5_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_5_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_6_acalcvm(self):
		"""Test acalcvm mult  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_6_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_6_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_6_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_7_acalcvm(self):
		"""Test acalcvm mult  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_7_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_7_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_7_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_1_acalcvm(self):
		"""Test acalcvm div  - Array code b.
		"""
		# Template name: test_template_intdiv
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_2_acalcvm(self):
		"""Test acalcvm div  - Array code b.
		"""
		# Template name: test_template_intdiv
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_3_acalcvm(self):
		"""Test acalcvm div  - Array code b.
		"""
		# Template name: test_template_intdiv
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_4_acalcvm(self):
		"""Test acalcvm div  - Array code b.
		"""
		# Template name: test_template_intdiv
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_4_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_4_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_4_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_1_acalcvm(self):
		"""Test acalcvm floordiv  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_2_acalcvm(self):
		"""Test acalcvm floordiv  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_3_acalcvm(self):
		"""Test acalcvm floordiv  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_3_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_3_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_3_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_4_acalcvm(self):
		"""Test acalcvm floordiv  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_4_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_4_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_4_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_1_acalcvm(self):
		"""Test acalcvm mod  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_2_acalcvm(self):
		"""Test acalcvm mod  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_3_acalcvm(self):
		"""Test acalcvm mod  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_3_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_3_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_3_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_4_acalcvm(self):
		"""Test acalcvm mod  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_4_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_4_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_4_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_uadd_1_acalcvm(self):
		"""Test acalcvm uadd  - Array code b.
		"""
		# Template name: test_template_1op
		data = array.array('b', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [+x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_ov(self):
		"""Test acalcvm uadd with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [+x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_lim(self):
		"""Test acalcvm uadd with array limit  - Array code b.
		"""
		data = array.array('b', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [+x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_ov_lim(self):
		"""Test acalcvm uadd with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [+x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_usub_1_acalcvm(self):
		"""Test acalcvm usub  - Array code b.
		"""
		# Template name: test_template_1op
		data = array.array('b', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [-x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_usub_1_acalcvm_ov(self):
		"""Test acalcvm usub with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [-x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_usub_1_acalcvm_lim(self):
		"""Test acalcvm usub with array limit  - Array code b.
		"""
		data = array.array('b', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [-x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_usub_1_acalcvm_ov_lim(self):
		"""Test acalcvm usub with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [-x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_1_acalcvm(self):
		"""Test acalcvm pow  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_2_acalcvm(self):
		"""Test acalcvm pow  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_3_acalcvm(self):
		"""Test acalcvm pow  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_1_acalcvm(self):
		"""Test acalcvm bitand  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_2_acalcvm(self):
		"""Test acalcvm bitand  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_3_acalcvm(self):
		"""Test acalcvm bitand  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_4_acalcvm(self):
		"""Test acalcvm bitand  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_5_acalcvm(self):
		"""Test acalcvm bitand  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_6_acalcvm(self):
		"""Test acalcvm bitand  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_1_acalcvm(self):
		"""Test acalcvm bitor  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_2_acalcvm(self):
		"""Test acalcvm bitor  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_3_acalcvm(self):
		"""Test acalcvm bitor  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_4_acalcvm(self):
		"""Test acalcvm bitor  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_5_acalcvm(self):
		"""Test acalcvm bitor  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_6_acalcvm(self):
		"""Test acalcvm bitor  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_1_acalcvm(self):
		"""Test acalcvm bitxor  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_2_acalcvm(self):
		"""Test acalcvm bitxor  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_3_acalcvm(self):
		"""Test acalcvm bitxor  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_4_acalcvm(self):
		"""Test acalcvm bitxor  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_5_acalcvm(self):
		"""Test acalcvm bitxor  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_6_acalcvm(self):
		"""Test acalcvm bitxor  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_invert_1_acalcvm(self):
		"""Test acalcvm invert  - Array code b.
		"""
		# Template name: test_template_intinvert
		data = array.array('b', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [InvertPy('b', x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_ov(self):
		"""Test acalcvm invert with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [InvertPy('b', x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_lim(self):
		"""Test acalcvm invert with array limit  - Array code b.
		"""
		data = array.array('b', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [InvertPy('b', x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_ov_lim(self):
		"""Test acalcvm invert with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [InvertPy('b', x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_1_acalcvm(self):
		"""Test acalcvm lshift  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_2_acalcvm(self):
		"""Test acalcvm lshift  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_3_acalcvm(self):
		"""Test acalcvm lshift  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_1_acalcvm(self):
		"""Test acalcvm rshift  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_2_acalcvm(self):
		"""Test acalcvm rshift  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_3_acalcvm(self):
		"""Test acalcvm rshift  - Array code b.
		"""
		# Template name: test_template_2ops
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_abs_1_acalcvm(self):
		"""Test acalcvm abs  - Array code b.
		"""
		# Template name: test_template_1op
		data = array.array('b', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [abs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_ov(self):
		"""Test acalcvm abs with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [abs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_lim(self):
		"""Test acalcvm abs with array limit  - Array code b.
		"""
		data = array.array('b', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [abs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_ov_lim(self):
		"""Test acalcvm abs with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [abs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_math_factorial_1_acalcvm(self):
		"""Test acalcvm math_factorial  - Array code b.
		"""
		# Template name: test_template_1op
		data = array.array('b', [0,1,2,3,4,5])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [math.factorial(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_ov(self):
		"""Test acalcvm math_factorial with overflow checking disabled  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5])
		
		dataout = array.array('b', [0]*len(data))
		

		expected = [math.factorial(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_lim(self):
		"""Test acalcvm math_factorial with array limit  - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.factorial(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_factorial with overflow checking disabled and array limit - Array code b.
		"""
		data = array.array('b', [0,1,2,3,4,5])
		
		dataout = array.array('b', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.factorial(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)


##############################################################################

##############################################################################
class acalcvm_operator_B(unittest.TestCase):
	"""Test for basic operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'


	########################################################
	def test_operator_add_1_acalcvm(self):
		"""Test acalcvm add  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_2_acalcvm(self):
		"""Test acalcvm add  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_3_acalcvm(self):
		"""Test acalcvm add  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_1_acalcvm(self):
		"""Test acalcvm sub  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_2_acalcvm(self):
		"""Test acalcvm sub  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_3_acalcvm(self):
		"""Test acalcvm sub  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_1_acalcvm(self):
		"""Test acalcvm mult  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_2_acalcvm(self):
		"""Test acalcvm mult  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_3_acalcvm(self):
		"""Test acalcvm mult  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_4_acalcvm(self):
		"""Test acalcvm mult  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_1_acalcvm(self):
		"""Test acalcvm div  - Array code B.
		"""
		# Template name: test_template_intdiv
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_2_acalcvm(self):
		"""Test acalcvm div  - Array code B.
		"""
		# Template name: test_template_intdiv
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_3_acalcvm(self):
		"""Test acalcvm div  - Array code B.
		"""
		# Template name: test_template_intdiv
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_1_acalcvm(self):
		"""Test acalcvm floordiv  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_2_acalcvm(self):
		"""Test acalcvm floordiv  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_1_acalcvm(self):
		"""Test acalcvm mod  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_2_acalcvm(self):
		"""Test acalcvm mod  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_uadd_1_acalcvm(self):
		"""Test acalcvm uadd  - Array code B.
		"""
		# Template name: test_template_1op
		data = array.array('B', [0,1,2,3,4,5])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [+x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_ov(self):
		"""Test acalcvm uadd with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [+x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_lim(self):
		"""Test acalcvm uadd with array limit  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [+x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_ov_lim(self):
		"""Test acalcvm uadd with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [+x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_1_acalcvm(self):
		"""Test acalcvm pow  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_2_acalcvm(self):
		"""Test acalcvm pow  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_3_acalcvm(self):
		"""Test acalcvm pow  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_1_acalcvm(self):
		"""Test acalcvm bitand  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_2_acalcvm(self):
		"""Test acalcvm bitand  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_3_acalcvm(self):
		"""Test acalcvm bitand  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_4_acalcvm(self):
		"""Test acalcvm bitand  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_5_acalcvm(self):
		"""Test acalcvm bitand  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_6_acalcvm(self):
		"""Test acalcvm bitand  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_1_acalcvm(self):
		"""Test acalcvm bitor  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_2_acalcvm(self):
		"""Test acalcvm bitor  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_3_acalcvm(self):
		"""Test acalcvm bitor  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_4_acalcvm(self):
		"""Test acalcvm bitor  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_5_acalcvm(self):
		"""Test acalcvm bitor  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_6_acalcvm(self):
		"""Test acalcvm bitor  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_1_acalcvm(self):
		"""Test acalcvm bitxor  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_2_acalcvm(self):
		"""Test acalcvm bitxor  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_3_acalcvm(self):
		"""Test acalcvm bitxor  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_4_acalcvm(self):
		"""Test acalcvm bitxor  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_5_acalcvm(self):
		"""Test acalcvm bitxor  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_6_acalcvm(self):
		"""Test acalcvm bitxor  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_invert_1_acalcvm(self):
		"""Test acalcvm invert  - Array code B.
		"""
		# Template name: test_template_intinvert
		data = array.array('B', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [InvertPy('B', x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_ov(self):
		"""Test acalcvm invert with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [InvertPy('B', x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_lim(self):
		"""Test acalcvm invert with array limit  - Array code B.
		"""
		data = array.array('B', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [InvertPy('B', x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_ov_lim(self):
		"""Test acalcvm invert with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [InvertPy('B', x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_1_acalcvm(self):
		"""Test acalcvm lshift  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_2_acalcvm(self):
		"""Test acalcvm lshift  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_3_acalcvm(self):
		"""Test acalcvm lshift  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_1_acalcvm(self):
		"""Test acalcvm rshift  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_2_acalcvm(self):
		"""Test acalcvm rshift  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_3_acalcvm(self):
		"""Test acalcvm rshift  - Array code B.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_abs_1_acalcvm(self):
		"""Test acalcvm abs  - Array code B.
		"""
		# Template name: test_template_1op
		data = array.array('B', [0,1,2,3,4])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [abs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_ov(self):
		"""Test acalcvm abs with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [abs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_lim(self):
		"""Test acalcvm abs with array limit  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [abs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_ov_lim(self):
		"""Test acalcvm abs with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [abs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_math_factorial_1_acalcvm(self):
		"""Test acalcvm math_factorial  - Array code B.
		"""
		# Template name: test_template_1op
		data = array.array('B', [0,1,2,3,4,5])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [math.factorial(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_ov(self):
		"""Test acalcvm math_factorial with overflow checking disabled  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5])
		
		dataout = array.array('B', [0]*len(data))
		

		expected = [math.factorial(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_lim(self):
		"""Test acalcvm math_factorial with array limit  - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.factorial(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_factorial with overflow checking disabled and array limit - Array code B.
		"""
		data = array.array('B', [0,1,2,3,4,5])
		
		dataout = array.array('B', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.factorial(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)


##############################################################################

##############################################################################
class acalcvm_operator_h(unittest.TestCase):
	"""Test for basic operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'h'


	########################################################
	def test_operator_add_1_acalcvm(self):
		"""Test acalcvm add  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat(-25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat(-25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat(-25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat(-25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_2_acalcvm(self):
		"""Test acalcvm add  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_3_acalcvm(self):
		"""Test acalcvm add  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_4_acalcvm(self):
		"""Test acalcvm add  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_4_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_4_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_4_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_5_acalcvm(self):
		"""Test acalcvm add  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_5_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_5_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_5_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_1_acalcvm(self):
		"""Test acalcvm sub  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_2_acalcvm(self):
		"""Test acalcvm sub  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_3_acalcvm(self):
		"""Test acalcvm sub  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_4_acalcvm(self):
		"""Test acalcvm sub  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_4_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_4_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_4_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_5_acalcvm(self):
		"""Test acalcvm sub  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_5_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_5_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_5_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_1_acalcvm(self):
		"""Test acalcvm mult  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat(-3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat(-3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat(-3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat(-3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_2_acalcvm(self):
		"""Test acalcvm mult  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( -2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( -2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( -2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( -2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_3_acalcvm(self):
		"""Test acalcvm mult  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_4_acalcvm(self):
		"""Test acalcvm mult  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_5_acalcvm(self):
		"""Test acalcvm mult  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_5_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_5_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_5_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_6_acalcvm(self):
		"""Test acalcvm mult  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_6_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_6_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_6_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_7_acalcvm(self):
		"""Test acalcvm mult  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_7_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_7_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_7_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_1_acalcvm(self):
		"""Test acalcvm div  - Array code h.
		"""
		# Template name: test_template_intdiv
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_2_acalcvm(self):
		"""Test acalcvm div  - Array code h.
		"""
		# Template name: test_template_intdiv
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_3_acalcvm(self):
		"""Test acalcvm div  - Array code h.
		"""
		# Template name: test_template_intdiv
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_4_acalcvm(self):
		"""Test acalcvm div  - Array code h.
		"""
		# Template name: test_template_intdiv
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_4_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_4_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_4_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_1_acalcvm(self):
		"""Test acalcvm floordiv  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_2_acalcvm(self):
		"""Test acalcvm floordiv  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_3_acalcvm(self):
		"""Test acalcvm floordiv  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_3_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_3_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_3_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_4_acalcvm(self):
		"""Test acalcvm floordiv  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_4_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_4_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_4_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_1_acalcvm(self):
		"""Test acalcvm mod  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_2_acalcvm(self):
		"""Test acalcvm mod  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_3_acalcvm(self):
		"""Test acalcvm mod  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_3_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_3_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_3_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_4_acalcvm(self):
		"""Test acalcvm mod  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_4_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_4_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_4_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_uadd_1_acalcvm(self):
		"""Test acalcvm uadd  - Array code h.
		"""
		# Template name: test_template_1op
		data = array.array('h', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [+x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_ov(self):
		"""Test acalcvm uadd with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [+x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_lim(self):
		"""Test acalcvm uadd with array limit  - Array code h.
		"""
		data = array.array('h', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [+x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_ov_lim(self):
		"""Test acalcvm uadd with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [+x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_usub_1_acalcvm(self):
		"""Test acalcvm usub  - Array code h.
		"""
		# Template name: test_template_1op
		data = array.array('h', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [-x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_usub_1_acalcvm_ov(self):
		"""Test acalcvm usub with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [-x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_usub_1_acalcvm_lim(self):
		"""Test acalcvm usub with array limit  - Array code h.
		"""
		data = array.array('h', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [-x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_usub_1_acalcvm_ov_lim(self):
		"""Test acalcvm usub with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [-x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_1_acalcvm(self):
		"""Test acalcvm pow  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_2_acalcvm(self):
		"""Test acalcvm pow  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_3_acalcvm(self):
		"""Test acalcvm pow  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_1_acalcvm(self):
		"""Test acalcvm bitand  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_2_acalcvm(self):
		"""Test acalcvm bitand  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_3_acalcvm(self):
		"""Test acalcvm bitand  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_4_acalcvm(self):
		"""Test acalcvm bitand  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_5_acalcvm(self):
		"""Test acalcvm bitand  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_6_acalcvm(self):
		"""Test acalcvm bitand  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_1_acalcvm(self):
		"""Test acalcvm bitor  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_2_acalcvm(self):
		"""Test acalcvm bitor  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_3_acalcvm(self):
		"""Test acalcvm bitor  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_4_acalcvm(self):
		"""Test acalcvm bitor  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_5_acalcvm(self):
		"""Test acalcvm bitor  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_6_acalcvm(self):
		"""Test acalcvm bitor  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_1_acalcvm(self):
		"""Test acalcvm bitxor  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_2_acalcvm(self):
		"""Test acalcvm bitxor  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_3_acalcvm(self):
		"""Test acalcvm bitxor  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_4_acalcvm(self):
		"""Test acalcvm bitxor  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_5_acalcvm(self):
		"""Test acalcvm bitxor  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_6_acalcvm(self):
		"""Test acalcvm bitxor  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_invert_1_acalcvm(self):
		"""Test acalcvm invert  - Array code h.
		"""
		# Template name: test_template_intinvert
		data = array.array('h', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [InvertPy('h', x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_ov(self):
		"""Test acalcvm invert with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [InvertPy('h', x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_lim(self):
		"""Test acalcvm invert with array limit  - Array code h.
		"""
		data = array.array('h', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [InvertPy('h', x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_ov_lim(self):
		"""Test acalcvm invert with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [InvertPy('h', x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_1_acalcvm(self):
		"""Test acalcvm lshift  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_2_acalcvm(self):
		"""Test acalcvm lshift  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_3_acalcvm(self):
		"""Test acalcvm lshift  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_1_acalcvm(self):
		"""Test acalcvm rshift  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_2_acalcvm(self):
		"""Test acalcvm rshift  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_3_acalcvm(self):
		"""Test acalcvm rshift  - Array code h.
		"""
		# Template name: test_template_2ops
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_abs_1_acalcvm(self):
		"""Test acalcvm abs  - Array code h.
		"""
		# Template name: test_template_1op
		data = array.array('h', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [abs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_ov(self):
		"""Test acalcvm abs with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [abs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_lim(self):
		"""Test acalcvm abs with array limit  - Array code h.
		"""
		data = array.array('h', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [abs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_ov_lim(self):
		"""Test acalcvm abs with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [abs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_math_factorial_1_acalcvm(self):
		"""Test acalcvm math_factorial  - Array code h.
		"""
		# Template name: test_template_1op
		data = array.array('h', [0,1,2,3,4,5])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [math.factorial(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_ov(self):
		"""Test acalcvm math_factorial with overflow checking disabled  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5])
		
		dataout = array.array('h', [0]*len(data))
		

		expected = [math.factorial(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_lim(self):
		"""Test acalcvm math_factorial with array limit  - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.factorial(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_factorial with overflow checking disabled and array limit - Array code h.
		"""
		data = array.array('h', [0,1,2,3,4,5])
		
		dataout = array.array('h', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.factorial(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)


##############################################################################

##############################################################################
class acalcvm_operator_H(unittest.TestCase):
	"""Test for basic operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'H'


	########################################################
	def test_operator_add_1_acalcvm(self):
		"""Test acalcvm add  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_2_acalcvm(self):
		"""Test acalcvm add  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_3_acalcvm(self):
		"""Test acalcvm add  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_1_acalcvm(self):
		"""Test acalcvm sub  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_2_acalcvm(self):
		"""Test acalcvm sub  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_3_acalcvm(self):
		"""Test acalcvm sub  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_1_acalcvm(self):
		"""Test acalcvm mult  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_2_acalcvm(self):
		"""Test acalcvm mult  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_3_acalcvm(self):
		"""Test acalcvm mult  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_4_acalcvm(self):
		"""Test acalcvm mult  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_1_acalcvm(self):
		"""Test acalcvm div  - Array code H.
		"""
		# Template name: test_template_intdiv
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_2_acalcvm(self):
		"""Test acalcvm div  - Array code H.
		"""
		# Template name: test_template_intdiv
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_3_acalcvm(self):
		"""Test acalcvm div  - Array code H.
		"""
		# Template name: test_template_intdiv
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_1_acalcvm(self):
		"""Test acalcvm floordiv  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_2_acalcvm(self):
		"""Test acalcvm floordiv  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_1_acalcvm(self):
		"""Test acalcvm mod  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_2_acalcvm(self):
		"""Test acalcvm mod  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_uadd_1_acalcvm(self):
		"""Test acalcvm uadd  - Array code H.
		"""
		# Template name: test_template_1op
		data = array.array('H', [0,1,2,3,4,5])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [+x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_ov(self):
		"""Test acalcvm uadd with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [+x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_lim(self):
		"""Test acalcvm uadd with array limit  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [+x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_ov_lim(self):
		"""Test acalcvm uadd with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [+x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_1_acalcvm(self):
		"""Test acalcvm pow  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_2_acalcvm(self):
		"""Test acalcvm pow  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_3_acalcvm(self):
		"""Test acalcvm pow  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_1_acalcvm(self):
		"""Test acalcvm bitand  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_2_acalcvm(self):
		"""Test acalcvm bitand  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_3_acalcvm(self):
		"""Test acalcvm bitand  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_4_acalcvm(self):
		"""Test acalcvm bitand  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_5_acalcvm(self):
		"""Test acalcvm bitand  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_6_acalcvm(self):
		"""Test acalcvm bitand  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_1_acalcvm(self):
		"""Test acalcvm bitor  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_2_acalcvm(self):
		"""Test acalcvm bitor  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_3_acalcvm(self):
		"""Test acalcvm bitor  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_4_acalcvm(self):
		"""Test acalcvm bitor  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_5_acalcvm(self):
		"""Test acalcvm bitor  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_6_acalcvm(self):
		"""Test acalcvm bitor  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_1_acalcvm(self):
		"""Test acalcvm bitxor  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_2_acalcvm(self):
		"""Test acalcvm bitxor  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_3_acalcvm(self):
		"""Test acalcvm bitxor  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_4_acalcvm(self):
		"""Test acalcvm bitxor  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_5_acalcvm(self):
		"""Test acalcvm bitxor  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_6_acalcvm(self):
		"""Test acalcvm bitxor  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_invert_1_acalcvm(self):
		"""Test acalcvm invert  - Array code H.
		"""
		# Template name: test_template_intinvert
		data = array.array('H', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [InvertPy('H', x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_ov(self):
		"""Test acalcvm invert with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [InvertPy('H', x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_lim(self):
		"""Test acalcvm invert with array limit  - Array code H.
		"""
		data = array.array('H', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [InvertPy('H', x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_ov_lim(self):
		"""Test acalcvm invert with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [InvertPy('H', x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_1_acalcvm(self):
		"""Test acalcvm lshift  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_2_acalcvm(self):
		"""Test acalcvm lshift  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_3_acalcvm(self):
		"""Test acalcvm lshift  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_1_acalcvm(self):
		"""Test acalcvm rshift  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_2_acalcvm(self):
		"""Test acalcvm rshift  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_3_acalcvm(self):
		"""Test acalcvm rshift  - Array code H.
		"""
		# Template name: test_template_2ops
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_abs_1_acalcvm(self):
		"""Test acalcvm abs  - Array code H.
		"""
		# Template name: test_template_1op
		data = array.array('H', [0,1,2,3,4])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [abs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_ov(self):
		"""Test acalcvm abs with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [abs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_lim(self):
		"""Test acalcvm abs with array limit  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [abs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_ov_lim(self):
		"""Test acalcvm abs with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [abs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_math_factorial_1_acalcvm(self):
		"""Test acalcvm math_factorial  - Array code H.
		"""
		# Template name: test_template_1op
		data = array.array('H', [0,1,2,3,4,5])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [math.factorial(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_ov(self):
		"""Test acalcvm math_factorial with overflow checking disabled  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5])
		
		dataout = array.array('H', [0]*len(data))
		

		expected = [math.factorial(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_lim(self):
		"""Test acalcvm math_factorial with array limit  - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.factorial(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_factorial with overflow checking disabled and array limit - Array code H.
		"""
		data = array.array('H', [0,1,2,3,4,5])
		
		dataout = array.array('H', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.factorial(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)


##############################################################################

##############################################################################
class acalcvm_operator_i(unittest.TestCase):
	"""Test for basic operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'i'


	########################################################
	def test_operator_add_1_acalcvm(self):
		"""Test acalcvm add  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat(-25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat(-25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat(-25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat(-25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_2_acalcvm(self):
		"""Test acalcvm add  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_3_acalcvm(self):
		"""Test acalcvm add  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_4_acalcvm(self):
		"""Test acalcvm add  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_4_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_4_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_4_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_5_acalcvm(self):
		"""Test acalcvm add  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_5_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_5_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_5_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_1_acalcvm(self):
		"""Test acalcvm sub  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_2_acalcvm(self):
		"""Test acalcvm sub  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_3_acalcvm(self):
		"""Test acalcvm sub  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_4_acalcvm(self):
		"""Test acalcvm sub  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_4_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_4_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_4_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_5_acalcvm(self):
		"""Test acalcvm sub  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_5_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_5_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_5_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_1_acalcvm(self):
		"""Test acalcvm mult  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat(-3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat(-3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat(-3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat(-3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_2_acalcvm(self):
		"""Test acalcvm mult  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( -2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( -2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( -2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( -2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_3_acalcvm(self):
		"""Test acalcvm mult  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_4_acalcvm(self):
		"""Test acalcvm mult  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_5_acalcvm(self):
		"""Test acalcvm mult  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_5_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_5_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_5_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_6_acalcvm(self):
		"""Test acalcvm mult  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_6_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_6_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_6_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_7_acalcvm(self):
		"""Test acalcvm mult  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_7_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_7_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_7_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_1_acalcvm(self):
		"""Test acalcvm div  - Array code i.
		"""
		# Template name: test_template_intdiv
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_2_acalcvm(self):
		"""Test acalcvm div  - Array code i.
		"""
		# Template name: test_template_intdiv
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_3_acalcvm(self):
		"""Test acalcvm div  - Array code i.
		"""
		# Template name: test_template_intdiv
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_4_acalcvm(self):
		"""Test acalcvm div  - Array code i.
		"""
		# Template name: test_template_intdiv
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_4_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_4_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_4_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_1_acalcvm(self):
		"""Test acalcvm floordiv  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_2_acalcvm(self):
		"""Test acalcvm floordiv  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_3_acalcvm(self):
		"""Test acalcvm floordiv  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_3_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_3_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_3_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_4_acalcvm(self):
		"""Test acalcvm floordiv  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_4_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_4_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_4_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_1_acalcvm(self):
		"""Test acalcvm mod  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_2_acalcvm(self):
		"""Test acalcvm mod  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_3_acalcvm(self):
		"""Test acalcvm mod  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_3_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_3_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_3_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_4_acalcvm(self):
		"""Test acalcvm mod  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_4_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_4_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_4_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_uadd_1_acalcvm(self):
		"""Test acalcvm uadd  - Array code i.
		"""
		# Template name: test_template_1op
		data = array.array('i', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [+x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_ov(self):
		"""Test acalcvm uadd with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [+x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_lim(self):
		"""Test acalcvm uadd with array limit  - Array code i.
		"""
		data = array.array('i', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [+x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_ov_lim(self):
		"""Test acalcvm uadd with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [+x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_usub_1_acalcvm(self):
		"""Test acalcvm usub  - Array code i.
		"""
		# Template name: test_template_1op
		data = array.array('i', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [-x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_usub_1_acalcvm_ov(self):
		"""Test acalcvm usub with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [-x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_usub_1_acalcvm_lim(self):
		"""Test acalcvm usub with array limit  - Array code i.
		"""
		data = array.array('i', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [-x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_usub_1_acalcvm_ov_lim(self):
		"""Test acalcvm usub with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [-x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_1_acalcvm(self):
		"""Test acalcvm pow  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_2_acalcvm(self):
		"""Test acalcvm pow  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_3_acalcvm(self):
		"""Test acalcvm pow  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_1_acalcvm(self):
		"""Test acalcvm bitand  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_2_acalcvm(self):
		"""Test acalcvm bitand  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_3_acalcvm(self):
		"""Test acalcvm bitand  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_4_acalcvm(self):
		"""Test acalcvm bitand  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_5_acalcvm(self):
		"""Test acalcvm bitand  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_6_acalcvm(self):
		"""Test acalcvm bitand  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_1_acalcvm(self):
		"""Test acalcvm bitor  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_2_acalcvm(self):
		"""Test acalcvm bitor  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_3_acalcvm(self):
		"""Test acalcvm bitor  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_4_acalcvm(self):
		"""Test acalcvm bitor  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_5_acalcvm(self):
		"""Test acalcvm bitor  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_6_acalcvm(self):
		"""Test acalcvm bitor  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_1_acalcvm(self):
		"""Test acalcvm bitxor  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_2_acalcvm(self):
		"""Test acalcvm bitxor  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_3_acalcvm(self):
		"""Test acalcvm bitxor  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_4_acalcvm(self):
		"""Test acalcvm bitxor  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_5_acalcvm(self):
		"""Test acalcvm bitxor  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_6_acalcvm(self):
		"""Test acalcvm bitxor  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_invert_1_acalcvm(self):
		"""Test acalcvm invert  - Array code i.
		"""
		# Template name: test_template_intinvert
		data = array.array('i', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [InvertPy('i', x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_ov(self):
		"""Test acalcvm invert with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [InvertPy('i', x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_lim(self):
		"""Test acalcvm invert with array limit  - Array code i.
		"""
		data = array.array('i', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [InvertPy('i', x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_ov_lim(self):
		"""Test acalcvm invert with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [InvertPy('i', x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_1_acalcvm(self):
		"""Test acalcvm lshift  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_2_acalcvm(self):
		"""Test acalcvm lshift  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_3_acalcvm(self):
		"""Test acalcvm lshift  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_1_acalcvm(self):
		"""Test acalcvm rshift  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_2_acalcvm(self):
		"""Test acalcvm rshift  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_3_acalcvm(self):
		"""Test acalcvm rshift  - Array code i.
		"""
		# Template name: test_template_2ops
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_abs_1_acalcvm(self):
		"""Test acalcvm abs  - Array code i.
		"""
		# Template name: test_template_1op
		data = array.array('i', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [abs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_ov(self):
		"""Test acalcvm abs with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [abs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_lim(self):
		"""Test acalcvm abs with array limit  - Array code i.
		"""
		data = array.array('i', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [abs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_ov_lim(self):
		"""Test acalcvm abs with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [abs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_math_factorial_1_acalcvm(self):
		"""Test acalcvm math_factorial  - Array code i.
		"""
		# Template name: test_template_1op
		data = array.array('i', [0,1,2,3,4,5])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [math.factorial(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_ov(self):
		"""Test acalcvm math_factorial with overflow checking disabled  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5])
		
		dataout = array.array('i', [0]*len(data))
		

		expected = [math.factorial(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_lim(self):
		"""Test acalcvm math_factorial with array limit  - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.factorial(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_factorial with overflow checking disabled and array limit - Array code i.
		"""
		data = array.array('i', [0,1,2,3,4,5])
		
		dataout = array.array('i', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.factorial(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)


##############################################################################

##############################################################################
class acalcvm_operator_I(unittest.TestCase):
	"""Test for basic operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'I'


	########################################################
	def test_operator_add_1_acalcvm(self):
		"""Test acalcvm add  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_2_acalcvm(self):
		"""Test acalcvm add  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_3_acalcvm(self):
		"""Test acalcvm add  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_1_acalcvm(self):
		"""Test acalcvm sub  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_2_acalcvm(self):
		"""Test acalcvm sub  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_3_acalcvm(self):
		"""Test acalcvm sub  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_1_acalcvm(self):
		"""Test acalcvm mult  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_2_acalcvm(self):
		"""Test acalcvm mult  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_3_acalcvm(self):
		"""Test acalcvm mult  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_4_acalcvm(self):
		"""Test acalcvm mult  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_1_acalcvm(self):
		"""Test acalcvm div  - Array code I.
		"""
		# Template name: test_template_intdiv
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_2_acalcvm(self):
		"""Test acalcvm div  - Array code I.
		"""
		# Template name: test_template_intdiv
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_3_acalcvm(self):
		"""Test acalcvm div  - Array code I.
		"""
		# Template name: test_template_intdiv
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_1_acalcvm(self):
		"""Test acalcvm floordiv  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_2_acalcvm(self):
		"""Test acalcvm floordiv  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_1_acalcvm(self):
		"""Test acalcvm mod  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_2_acalcvm(self):
		"""Test acalcvm mod  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_uadd_1_acalcvm(self):
		"""Test acalcvm uadd  - Array code I.
		"""
		# Template name: test_template_1op
		data = array.array('I', [0,1,2,3,4,5])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [+x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_ov(self):
		"""Test acalcvm uadd with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [+x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_lim(self):
		"""Test acalcvm uadd with array limit  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [+x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_ov_lim(self):
		"""Test acalcvm uadd with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [+x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_1_acalcvm(self):
		"""Test acalcvm pow  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_2_acalcvm(self):
		"""Test acalcvm pow  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_3_acalcvm(self):
		"""Test acalcvm pow  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_1_acalcvm(self):
		"""Test acalcvm bitand  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_2_acalcvm(self):
		"""Test acalcvm bitand  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_3_acalcvm(self):
		"""Test acalcvm bitand  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_4_acalcvm(self):
		"""Test acalcvm bitand  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_5_acalcvm(self):
		"""Test acalcvm bitand  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_6_acalcvm(self):
		"""Test acalcvm bitand  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_1_acalcvm(self):
		"""Test acalcvm bitor  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_2_acalcvm(self):
		"""Test acalcvm bitor  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_3_acalcvm(self):
		"""Test acalcvm bitor  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_4_acalcvm(self):
		"""Test acalcvm bitor  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_5_acalcvm(self):
		"""Test acalcvm bitor  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_6_acalcvm(self):
		"""Test acalcvm bitor  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_1_acalcvm(self):
		"""Test acalcvm bitxor  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_2_acalcvm(self):
		"""Test acalcvm bitxor  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_3_acalcvm(self):
		"""Test acalcvm bitxor  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_4_acalcvm(self):
		"""Test acalcvm bitxor  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_5_acalcvm(self):
		"""Test acalcvm bitxor  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_6_acalcvm(self):
		"""Test acalcvm bitxor  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_invert_1_acalcvm(self):
		"""Test acalcvm invert  - Array code I.
		"""
		# Template name: test_template_intinvert
		data = array.array('I', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [InvertPy('I', x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_ov(self):
		"""Test acalcvm invert with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [InvertPy('I', x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_lim(self):
		"""Test acalcvm invert with array limit  - Array code I.
		"""
		data = array.array('I', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [InvertPy('I', x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_ov_lim(self):
		"""Test acalcvm invert with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [InvertPy('I', x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_1_acalcvm(self):
		"""Test acalcvm lshift  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_2_acalcvm(self):
		"""Test acalcvm lshift  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_3_acalcvm(self):
		"""Test acalcvm lshift  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_1_acalcvm(self):
		"""Test acalcvm rshift  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_2_acalcvm(self):
		"""Test acalcvm rshift  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_3_acalcvm(self):
		"""Test acalcvm rshift  - Array code I.
		"""
		# Template name: test_template_2ops
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_abs_1_acalcvm(self):
		"""Test acalcvm abs  - Array code I.
		"""
		# Template name: test_template_1op
		data = array.array('I', [0,1,2,3,4])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [abs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_ov(self):
		"""Test acalcvm abs with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [abs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_lim(self):
		"""Test acalcvm abs with array limit  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [abs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_ov_lim(self):
		"""Test acalcvm abs with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [abs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_math_factorial_1_acalcvm(self):
		"""Test acalcvm math_factorial  - Array code I.
		"""
		# Template name: test_template_1op
		data = array.array('I', [0,1,2,3,4,5])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [math.factorial(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_ov(self):
		"""Test acalcvm math_factorial with overflow checking disabled  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5])
		
		dataout = array.array('I', [0]*len(data))
		

		expected = [math.factorial(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_lim(self):
		"""Test acalcvm math_factorial with array limit  - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.factorial(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_factorial with overflow checking disabled and array limit - Array code I.
		"""
		data = array.array('I', [0,1,2,3,4,5])
		
		dataout = array.array('I', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.factorial(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)


##############################################################################

##############################################################################
class acalcvm_operator_l(unittest.TestCase):
	"""Test for basic operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'l'


	########################################################
	def test_operator_add_1_acalcvm(self):
		"""Test acalcvm add  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat(-25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat(-25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat(-25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat(-25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_2_acalcvm(self):
		"""Test acalcvm add  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_3_acalcvm(self):
		"""Test acalcvm add  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_4_acalcvm(self):
		"""Test acalcvm add  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_4_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_4_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_4_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_5_acalcvm(self):
		"""Test acalcvm add  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_5_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_5_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_5_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_1_acalcvm(self):
		"""Test acalcvm sub  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_2_acalcvm(self):
		"""Test acalcvm sub  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_3_acalcvm(self):
		"""Test acalcvm sub  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_4_acalcvm(self):
		"""Test acalcvm sub  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_4_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_4_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_4_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_5_acalcvm(self):
		"""Test acalcvm sub  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_5_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_5_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_5_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_1_acalcvm(self):
		"""Test acalcvm mult  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat(-3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat(-3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat(-3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat(-3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_2_acalcvm(self):
		"""Test acalcvm mult  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( -2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( -2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( -2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( -2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_3_acalcvm(self):
		"""Test acalcvm mult  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_4_acalcvm(self):
		"""Test acalcvm mult  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_5_acalcvm(self):
		"""Test acalcvm mult  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_5_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_5_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_5_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_6_acalcvm(self):
		"""Test acalcvm mult  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_6_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_6_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_6_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_7_acalcvm(self):
		"""Test acalcvm mult  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_7_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_7_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_7_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_1_acalcvm(self):
		"""Test acalcvm div  - Array code l.
		"""
		# Template name: test_template_intdiv
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_2_acalcvm(self):
		"""Test acalcvm div  - Array code l.
		"""
		# Template name: test_template_intdiv
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_3_acalcvm(self):
		"""Test acalcvm div  - Array code l.
		"""
		# Template name: test_template_intdiv
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_4_acalcvm(self):
		"""Test acalcvm div  - Array code l.
		"""
		# Template name: test_template_intdiv
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_4_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_4_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_4_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_1_acalcvm(self):
		"""Test acalcvm floordiv  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_2_acalcvm(self):
		"""Test acalcvm floordiv  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_3_acalcvm(self):
		"""Test acalcvm floordiv  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_3_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_3_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_3_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_4_acalcvm(self):
		"""Test acalcvm floordiv  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_4_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_4_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_4_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_1_acalcvm(self):
		"""Test acalcvm mod  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_2_acalcvm(self):
		"""Test acalcvm mod  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_3_acalcvm(self):
		"""Test acalcvm mod  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_3_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_3_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_3_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_4_acalcvm(self):
		"""Test acalcvm mod  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_4_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_4_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_4_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_uadd_1_acalcvm(self):
		"""Test acalcvm uadd  - Array code l.
		"""
		# Template name: test_template_1op
		data = array.array('l', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [+x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_ov(self):
		"""Test acalcvm uadd with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [+x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_lim(self):
		"""Test acalcvm uadd with array limit  - Array code l.
		"""
		data = array.array('l', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [+x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_ov_lim(self):
		"""Test acalcvm uadd with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [+x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_usub_1_acalcvm(self):
		"""Test acalcvm usub  - Array code l.
		"""
		# Template name: test_template_1op
		data = array.array('l', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [-x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_usub_1_acalcvm_ov(self):
		"""Test acalcvm usub with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [-x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_usub_1_acalcvm_lim(self):
		"""Test acalcvm usub with array limit  - Array code l.
		"""
		data = array.array('l', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [-x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_usub_1_acalcvm_ov_lim(self):
		"""Test acalcvm usub with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [-x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_1_acalcvm(self):
		"""Test acalcvm pow  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_2_acalcvm(self):
		"""Test acalcvm pow  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_3_acalcvm(self):
		"""Test acalcvm pow  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_1_acalcvm(self):
		"""Test acalcvm bitand  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_2_acalcvm(self):
		"""Test acalcvm bitand  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_3_acalcvm(self):
		"""Test acalcvm bitand  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_4_acalcvm(self):
		"""Test acalcvm bitand  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_5_acalcvm(self):
		"""Test acalcvm bitand  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_6_acalcvm(self):
		"""Test acalcvm bitand  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_1_acalcvm(self):
		"""Test acalcvm bitor  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_2_acalcvm(self):
		"""Test acalcvm bitor  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_3_acalcvm(self):
		"""Test acalcvm bitor  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_4_acalcvm(self):
		"""Test acalcvm bitor  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_5_acalcvm(self):
		"""Test acalcvm bitor  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_6_acalcvm(self):
		"""Test acalcvm bitor  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_1_acalcvm(self):
		"""Test acalcvm bitxor  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_2_acalcvm(self):
		"""Test acalcvm bitxor  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_3_acalcvm(self):
		"""Test acalcvm bitxor  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_4_acalcvm(self):
		"""Test acalcvm bitxor  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_5_acalcvm(self):
		"""Test acalcvm bitxor  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_6_acalcvm(self):
		"""Test acalcvm bitxor  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_invert_1_acalcvm(self):
		"""Test acalcvm invert  - Array code l.
		"""
		# Template name: test_template_intinvert
		data = array.array('l', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [InvertPy('l', x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_ov(self):
		"""Test acalcvm invert with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [InvertPy('l', x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_lim(self):
		"""Test acalcvm invert with array limit  - Array code l.
		"""
		data = array.array('l', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [InvertPy('l', x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_ov_lim(self):
		"""Test acalcvm invert with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [InvertPy('l', x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_1_acalcvm(self):
		"""Test acalcvm lshift  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_2_acalcvm(self):
		"""Test acalcvm lshift  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_3_acalcvm(self):
		"""Test acalcvm lshift  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_1_acalcvm(self):
		"""Test acalcvm rshift  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_2_acalcvm(self):
		"""Test acalcvm rshift  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_3_acalcvm(self):
		"""Test acalcvm rshift  - Array code l.
		"""
		# Template name: test_template_2ops
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_abs_1_acalcvm(self):
		"""Test acalcvm abs  - Array code l.
		"""
		# Template name: test_template_1op
		data = array.array('l', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [abs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_ov(self):
		"""Test acalcvm abs with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [abs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_lim(self):
		"""Test acalcvm abs with array limit  - Array code l.
		"""
		data = array.array('l', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [abs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_ov_lim(self):
		"""Test acalcvm abs with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [abs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_math_factorial_1_acalcvm(self):
		"""Test acalcvm math_factorial  - Array code l.
		"""
		# Template name: test_template_1op
		data = array.array('l', [0,1,2,3,4,5])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [math.factorial(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_ov(self):
		"""Test acalcvm math_factorial with overflow checking disabled  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5])
		
		dataout = array.array('l', [0]*len(data))
		

		expected = [math.factorial(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_lim(self):
		"""Test acalcvm math_factorial with array limit  - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.factorial(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_factorial with overflow checking disabled and array limit - Array code l.
		"""
		data = array.array('l', [0,1,2,3,4,5])
		
		dataout = array.array('l', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.factorial(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)


##############################################################################

##############################################################################
class acalcvm_operator_L(unittest.TestCase):
	"""Test for basic operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'L'


	########################################################
	def test_operator_add_1_acalcvm(self):
		"""Test acalcvm add  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_2_acalcvm(self):
		"""Test acalcvm add  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_3_acalcvm(self):
		"""Test acalcvm add  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_1_acalcvm(self):
		"""Test acalcvm sub  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_2_acalcvm(self):
		"""Test acalcvm sub  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_3_acalcvm(self):
		"""Test acalcvm sub  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_1_acalcvm(self):
		"""Test acalcvm mult  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_2_acalcvm(self):
		"""Test acalcvm mult  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_3_acalcvm(self):
		"""Test acalcvm mult  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_4_acalcvm(self):
		"""Test acalcvm mult  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_1_acalcvm(self):
		"""Test acalcvm div  - Array code L.
		"""
		# Template name: test_template_intdiv
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_2_acalcvm(self):
		"""Test acalcvm div  - Array code L.
		"""
		# Template name: test_template_intdiv
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_3_acalcvm(self):
		"""Test acalcvm div  - Array code L.
		"""
		# Template name: test_template_intdiv
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_1_acalcvm(self):
		"""Test acalcvm floordiv  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_2_acalcvm(self):
		"""Test acalcvm floordiv  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_1_acalcvm(self):
		"""Test acalcvm mod  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_2_acalcvm(self):
		"""Test acalcvm mod  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_uadd_1_acalcvm(self):
		"""Test acalcvm uadd  - Array code L.
		"""
		# Template name: test_template_1op
		data = array.array('L', [0,1,2,3,4,5])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [+x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_ov(self):
		"""Test acalcvm uadd with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [+x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_lim(self):
		"""Test acalcvm uadd with array limit  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [+x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_ov_lim(self):
		"""Test acalcvm uadd with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [+x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_1_acalcvm(self):
		"""Test acalcvm pow  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_2_acalcvm(self):
		"""Test acalcvm pow  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_3_acalcvm(self):
		"""Test acalcvm pow  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_1_acalcvm(self):
		"""Test acalcvm bitand  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_2_acalcvm(self):
		"""Test acalcvm bitand  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_3_acalcvm(self):
		"""Test acalcvm bitand  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_4_acalcvm(self):
		"""Test acalcvm bitand  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_5_acalcvm(self):
		"""Test acalcvm bitand  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_6_acalcvm(self):
		"""Test acalcvm bitand  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_1_acalcvm(self):
		"""Test acalcvm bitor  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_2_acalcvm(self):
		"""Test acalcvm bitor  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_3_acalcvm(self):
		"""Test acalcvm bitor  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_4_acalcvm(self):
		"""Test acalcvm bitor  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_5_acalcvm(self):
		"""Test acalcvm bitor  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_6_acalcvm(self):
		"""Test acalcvm bitor  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_1_acalcvm(self):
		"""Test acalcvm bitxor  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_2_acalcvm(self):
		"""Test acalcvm bitxor  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_3_acalcvm(self):
		"""Test acalcvm bitxor  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_4_acalcvm(self):
		"""Test acalcvm bitxor  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_5_acalcvm(self):
		"""Test acalcvm bitxor  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_6_acalcvm(self):
		"""Test acalcvm bitxor  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_invert_1_acalcvm(self):
		"""Test acalcvm invert  - Array code L.
		"""
		# Template name: test_template_intinvert
		data = array.array('L', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [InvertPy('L', x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_ov(self):
		"""Test acalcvm invert with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [InvertPy('L', x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_lim(self):
		"""Test acalcvm invert with array limit  - Array code L.
		"""
		data = array.array('L', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [InvertPy('L', x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_ov_lim(self):
		"""Test acalcvm invert with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [InvertPy('L', x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_1_acalcvm(self):
		"""Test acalcvm lshift  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_2_acalcvm(self):
		"""Test acalcvm lshift  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_3_acalcvm(self):
		"""Test acalcvm lshift  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_1_acalcvm(self):
		"""Test acalcvm rshift  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_2_acalcvm(self):
		"""Test acalcvm rshift  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_3_acalcvm(self):
		"""Test acalcvm rshift  - Array code L.
		"""
		# Template name: test_template_2ops
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_abs_1_acalcvm(self):
		"""Test acalcvm abs  - Array code L.
		"""
		# Template name: test_template_1op
		data = array.array('L', [0,1,2,3,4])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [abs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_ov(self):
		"""Test acalcvm abs with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [abs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_lim(self):
		"""Test acalcvm abs with array limit  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [abs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_ov_lim(self):
		"""Test acalcvm abs with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [abs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_math_factorial_1_acalcvm(self):
		"""Test acalcvm math_factorial  - Array code L.
		"""
		# Template name: test_template_1op
		data = array.array('L', [0,1,2,3,4,5])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [math.factorial(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_ov(self):
		"""Test acalcvm math_factorial with overflow checking disabled  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5])
		
		dataout = array.array('L', [0]*len(data))
		

		expected = [math.factorial(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_lim(self):
		"""Test acalcvm math_factorial with array limit  - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.factorial(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_factorial with overflow checking disabled and array limit - Array code L.
		"""
		data = array.array('L', [0,1,2,3,4,5])
		
		dataout = array.array('L', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.factorial(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)


##############################################################################

##############################################################################
class acalcvm_operator_q(unittest.TestCase):
	"""Test for basic operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'q'


	########################################################
	def test_operator_add_1_acalcvm(self):
		"""Test acalcvm add  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat(-25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat(-25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat(-25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat(-25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_2_acalcvm(self):
		"""Test acalcvm add  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_3_acalcvm(self):
		"""Test acalcvm add  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_4_acalcvm(self):
		"""Test acalcvm add  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_4_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_4_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_4_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_5_acalcvm(self):
		"""Test acalcvm add  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_5_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_5_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_5_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_1_acalcvm(self):
		"""Test acalcvm sub  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_2_acalcvm(self):
		"""Test acalcvm sub  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_3_acalcvm(self):
		"""Test acalcvm sub  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_4_acalcvm(self):
		"""Test acalcvm sub  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_4_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_4_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_4_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_5_acalcvm(self):
		"""Test acalcvm sub  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_5_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_5_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_5_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_1_acalcvm(self):
		"""Test acalcvm mult  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat(-3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat(-3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat(-3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat(-3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_2_acalcvm(self):
		"""Test acalcvm mult  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( -2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( -2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( -2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( -2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_3_acalcvm(self):
		"""Test acalcvm mult  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_4_acalcvm(self):
		"""Test acalcvm mult  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_5_acalcvm(self):
		"""Test acalcvm mult  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_5_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_5_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_5_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_6_acalcvm(self):
		"""Test acalcvm mult  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_6_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_6_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_6_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_7_acalcvm(self):
		"""Test acalcvm mult  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_7_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_7_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_7_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_1_acalcvm(self):
		"""Test acalcvm div  - Array code q.
		"""
		# Template name: test_template_intdiv
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_2_acalcvm(self):
		"""Test acalcvm div  - Array code q.
		"""
		# Template name: test_template_intdiv
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_3_acalcvm(self):
		"""Test acalcvm div  - Array code q.
		"""
		# Template name: test_template_intdiv
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_4_acalcvm(self):
		"""Test acalcvm div  - Array code q.
		"""
		# Template name: test_template_intdiv
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_4_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_4_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_4_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_1_acalcvm(self):
		"""Test acalcvm floordiv  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_2_acalcvm(self):
		"""Test acalcvm floordiv  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_3_acalcvm(self):
		"""Test acalcvm floordiv  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_3_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_3_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_3_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_4_acalcvm(self):
		"""Test acalcvm floordiv  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_4_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_4_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_4_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_1_acalcvm(self):
		"""Test acalcvm mod  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_2_acalcvm(self):
		"""Test acalcvm mod  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_3_acalcvm(self):
		"""Test acalcvm mod  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_3_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_3_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_3_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_4_acalcvm(self):
		"""Test acalcvm mod  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_4_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_4_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_4_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_uadd_1_acalcvm(self):
		"""Test acalcvm uadd  - Array code q.
		"""
		# Template name: test_template_1op
		data = array.array('q', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [+x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_ov(self):
		"""Test acalcvm uadd with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [+x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_lim(self):
		"""Test acalcvm uadd with array limit  - Array code q.
		"""
		data = array.array('q', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [+x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_ov_lim(self):
		"""Test acalcvm uadd with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [+x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_usub_1_acalcvm(self):
		"""Test acalcvm usub  - Array code q.
		"""
		# Template name: test_template_1op
		data = array.array('q', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [-x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_usub_1_acalcvm_ov(self):
		"""Test acalcvm usub with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [-x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_usub_1_acalcvm_lim(self):
		"""Test acalcvm usub with array limit  - Array code q.
		"""
		data = array.array('q', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [-x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_usub_1_acalcvm_ov_lim(self):
		"""Test acalcvm usub with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [-x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_1_acalcvm(self):
		"""Test acalcvm pow  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_2_acalcvm(self):
		"""Test acalcvm pow  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_3_acalcvm(self):
		"""Test acalcvm pow  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_1_acalcvm(self):
		"""Test acalcvm bitand  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_2_acalcvm(self):
		"""Test acalcvm bitand  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_3_acalcvm(self):
		"""Test acalcvm bitand  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_4_acalcvm(self):
		"""Test acalcvm bitand  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_5_acalcvm(self):
		"""Test acalcvm bitand  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_6_acalcvm(self):
		"""Test acalcvm bitand  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_1_acalcvm(self):
		"""Test acalcvm bitor  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_2_acalcvm(self):
		"""Test acalcvm bitor  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_3_acalcvm(self):
		"""Test acalcvm bitor  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_4_acalcvm(self):
		"""Test acalcvm bitor  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_5_acalcvm(self):
		"""Test acalcvm bitor  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_6_acalcvm(self):
		"""Test acalcvm bitor  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_1_acalcvm(self):
		"""Test acalcvm bitxor  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_2_acalcvm(self):
		"""Test acalcvm bitxor  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_3_acalcvm(self):
		"""Test acalcvm bitxor  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_4_acalcvm(self):
		"""Test acalcvm bitxor  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_5_acalcvm(self):
		"""Test acalcvm bitxor  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_6_acalcvm(self):
		"""Test acalcvm bitxor  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_invert_1_acalcvm(self):
		"""Test acalcvm invert  - Array code q.
		"""
		# Template name: test_template_intinvert
		data = array.array('q', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [InvertPy('q', x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_ov(self):
		"""Test acalcvm invert with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [InvertPy('q', x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_lim(self):
		"""Test acalcvm invert with array limit  - Array code q.
		"""
		data = array.array('q', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [InvertPy('q', x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_ov_lim(self):
		"""Test acalcvm invert with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [InvertPy('q', x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_1_acalcvm(self):
		"""Test acalcvm lshift  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_2_acalcvm(self):
		"""Test acalcvm lshift  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_3_acalcvm(self):
		"""Test acalcvm lshift  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_1_acalcvm(self):
		"""Test acalcvm rshift  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_2_acalcvm(self):
		"""Test acalcvm rshift  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_3_acalcvm(self):
		"""Test acalcvm rshift  - Array code q.
		"""
		# Template name: test_template_2ops
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_abs_1_acalcvm(self):
		"""Test acalcvm abs  - Array code q.
		"""
		# Template name: test_template_1op
		data = array.array('q', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [abs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_ov(self):
		"""Test acalcvm abs with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [abs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_lim(self):
		"""Test acalcvm abs with array limit  - Array code q.
		"""
		data = array.array('q', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [abs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_ov_lim(self):
		"""Test acalcvm abs with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [-5,-4,-3,-2,-1,0,1,2,3,4])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [abs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_math_factorial_1_acalcvm(self):
		"""Test acalcvm math_factorial  - Array code q.
		"""
		# Template name: test_template_1op
		data = array.array('q', [0,1,2,3,4,5])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [math.factorial(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_ov(self):
		"""Test acalcvm math_factorial with overflow checking disabled  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5])
		
		dataout = array.array('q', [0]*len(data))
		

		expected = [math.factorial(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_lim(self):
		"""Test acalcvm math_factorial with array limit  - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.factorial(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_factorial with overflow checking disabled and array limit - Array code q.
		"""
		data = array.array('q', [0,1,2,3,4,5])
		
		dataout = array.array('q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.factorial(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)


##############################################################################

##############################################################################
class acalcvm_operator_Q(unittest.TestCase):
	"""Test for basic operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'Q'


	########################################################
	def test_operator_add_1_acalcvm(self):
		"""Test acalcvm add  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_2_acalcvm(self):
		"""Test acalcvm add  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_3_acalcvm(self):
		"""Test acalcvm add  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_1_acalcvm(self):
		"""Test acalcvm sub  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_2_acalcvm(self):
		"""Test acalcvm sub  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_3_acalcvm(self):
		"""Test acalcvm sub  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_1_acalcvm(self):
		"""Test acalcvm mult  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_2_acalcvm(self):
		"""Test acalcvm mult  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_3_acalcvm(self):
		"""Test acalcvm mult  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_4_acalcvm(self):
		"""Test acalcvm mult  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_1_acalcvm(self):
		"""Test acalcvm div  - Array code Q.
		"""
		# Template name: test_template_intdiv
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_2_acalcvm(self):
		"""Test acalcvm div  - Array code Q.
		"""
		# Template name: test_template_intdiv
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_3_acalcvm(self):
		"""Test acalcvm div  - Array code Q.
		"""
		# Template name: test_template_intdiv
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_1_acalcvm(self):
		"""Test acalcvm floordiv  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_2_acalcvm(self):
		"""Test acalcvm floordiv  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_1_acalcvm(self):
		"""Test acalcvm mod  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_2_acalcvm(self):
		"""Test acalcvm mod  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_uadd_1_acalcvm(self):
		"""Test acalcvm uadd  - Array code Q.
		"""
		# Template name: test_template_1op
		data = array.array('Q', [0,1,2,3,4,5])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [+x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_ov(self):
		"""Test acalcvm uadd with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [+x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_lim(self):
		"""Test acalcvm uadd with array limit  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [+x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_ov_lim(self):
		"""Test acalcvm uadd with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [+x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_1_acalcvm(self):
		"""Test acalcvm pow  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_2_acalcvm(self):
		"""Test acalcvm pow  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_3_acalcvm(self):
		"""Test acalcvm pow  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_1_acalcvm(self):
		"""Test acalcvm bitand  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_2_acalcvm(self):
		"""Test acalcvm bitand  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_3_acalcvm(self):
		"""Test acalcvm bitand  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_4_acalcvm(self):
		"""Test acalcvm bitand  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_5_acalcvm(self):
		"""Test acalcvm bitand  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_6_acalcvm(self):
		"""Test acalcvm bitand  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x & y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_1_acalcvm(self):
		"""Test acalcvm bitor  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_2_acalcvm(self):
		"""Test acalcvm bitor  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_3_acalcvm(self):
		"""Test acalcvm bitor  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_4_acalcvm(self):
		"""Test acalcvm bitor  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_5_acalcvm(self):
		"""Test acalcvm bitor  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_6_acalcvm(self):
		"""Test acalcvm bitor  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x | y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_1_acalcvm(self):
		"""Test acalcvm bitxor  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_2_acalcvm(self):
		"""Test acalcvm bitxor  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_3_acalcvm(self):
		"""Test acalcvm bitxor  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_4_acalcvm(self):
		"""Test acalcvm bitxor  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_5_acalcvm(self):
		"""Test acalcvm bitxor  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_6_acalcvm(self):
		"""Test acalcvm bitxor  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_invert_1_acalcvm(self):
		"""Test acalcvm invert  - Array code Q.
		"""
		# Template name: test_template_intinvert
		data = array.array('Q', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [InvertPy('Q', x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_ov(self):
		"""Test acalcvm invert with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [InvertPy('Q', x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_lim(self):
		"""Test acalcvm invert with array limit  - Array code Q.
		"""
		data = array.array('Q', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [InvertPy('Q', x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_ov_lim(self):
		"""Test acalcvm invert with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [1,2,3,4,5,6,7,8,9,10])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [InvertPy('Q', x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_1_acalcvm(self):
		"""Test acalcvm lshift  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_2_acalcvm(self):
		"""Test acalcvm lshift  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_3_acalcvm(self):
		"""Test acalcvm lshift  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5,6,7,8,9])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_1_acalcvm(self):
		"""Test acalcvm rshift  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_2_acalcvm(self):
		"""Test acalcvm rshift  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_3_acalcvm(self):
		"""Test acalcvm rshift  - Array code Q.
		"""
		# Template name: test_template_2ops
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_abs_1_acalcvm(self):
		"""Test acalcvm abs  - Array code Q.
		"""
		# Template name: test_template_1op
		data = array.array('Q', [0,1,2,3,4])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [abs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_ov(self):
		"""Test acalcvm abs with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [abs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_lim(self):
		"""Test acalcvm abs with array limit  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [abs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_ov_lim(self):
		"""Test acalcvm abs with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [abs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_math_factorial_1_acalcvm(self):
		"""Test acalcvm math_factorial  - Array code Q.
		"""
		# Template name: test_template_1op
		data = array.array('Q', [0,1,2,3,4,5])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [math.factorial(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_ov(self):
		"""Test acalcvm math_factorial with overflow checking disabled  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5])
		
		dataout = array.array('Q', [0]*len(data))
		

		expected = [math.factorial(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_lim(self):
		"""Test acalcvm math_factorial with array limit  - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.factorial(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_factorial with overflow checking disabled and array limit - Array code Q.
		"""
		data = array.array('Q', [0,1,2,3,4,5])
		
		dataout = array.array('Q', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.factorial(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)


##############################################################################

##############################################################################
class acalcvm_operator_f(unittest.TestCase):
	"""Test for basic operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'f'


	########################################################
	def test_operator_add_1_acalcvm(self):
		"""Test acalcvm add  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat(-25.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_1_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat(-25.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_1_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat(-25.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_1_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat(-25.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_add_2_acalcvm(self):
		"""Test acalcvm add  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_2_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_2_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_2_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_add_3_acalcvm(self):
		"""Test acalcvm add  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_3_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_3_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_3_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_add_4_acalcvm(self):
		"""Test acalcvm add  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_4_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_4_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_4_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_add_5_acalcvm(self):
		"""Test acalcvm add  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 25.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_5_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 25.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_5_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 25.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_5_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 25.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_sub_1_acalcvm(self):
		"""Test acalcvm sub  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat(-2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_1_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat(-2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_1_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat(-2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_1_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat(-2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_sub_2_acalcvm(self):
		"""Test acalcvm sub  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_2_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_2_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_2_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_sub_3_acalcvm(self):
		"""Test acalcvm sub  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_3_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_3_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_3_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_sub_4_acalcvm(self):
		"""Test acalcvm sub  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_4_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_4_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_4_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_sub_5_acalcvm(self):
		"""Test acalcvm sub  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_5_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_5_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_5_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_mult_1_acalcvm(self):
		"""Test acalcvm mult  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat(-3.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_1_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat(-3.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_1_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat(-3.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_1_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat(-3.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_mult_2_acalcvm(self):
		"""Test acalcvm mult  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( -2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_2_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( -2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_2_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( -2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_2_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( -2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_mult_3_acalcvm(self):
		"""Test acalcvm mult  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_3_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_3_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_3_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_mult_4_acalcvm(self):
		"""Test acalcvm mult  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_4_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_4_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_4_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_mult_5_acalcvm(self):
		"""Test acalcvm mult  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_5_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_5_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_5_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_mult_6_acalcvm(self):
		"""Test acalcvm mult  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_6_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_6_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_6_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_mult_7_acalcvm(self):
		"""Test acalcvm mult  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 3.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_7_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 3.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_7_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 3.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_7_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 3.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_div_1_acalcvm(self):
		"""Test acalcvm div  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x / y for x,y in zip(list(data), itertools.repeat(-2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_div_1_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x / y for x,y in zip(list(data), itertools.repeat(-2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_div_1_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x / y for x,y in zip(list(data), itertools.repeat(-2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_div_1_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x / y for x,y in zip(list(data), itertools.repeat(-2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_div_2_acalcvm(self):
		"""Test acalcvm div  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x / y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_div_2_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x / y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_div_2_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x / y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_div_2_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x / y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_div_3_acalcvm(self):
		"""Test acalcvm div  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x / y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_div_3_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x / y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_div_3_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x / y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_div_3_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x / y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_div_4_acalcvm(self):
		"""Test acalcvm div  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x / y for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_div_4_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x / y for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_div_4_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x / y for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_div_4_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x / y for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_floordiv_1_acalcvm(self):
		"""Test acalcvm floordiv  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat(-2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_floordiv_1_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat(-2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_floordiv_1_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat(-2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_floordiv_1_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat(-2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_floordiv_2_acalcvm(self):
		"""Test acalcvm floordiv  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_floordiv_2_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_floordiv_2_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_floordiv_2_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_floordiv_3_acalcvm(self):
		"""Test acalcvm floordiv  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_floordiv_3_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_floordiv_3_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_floordiv_3_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_floordiv_4_acalcvm(self):
		"""Test acalcvm floordiv  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_floordiv_4_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_floordiv_4_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_floordiv_4_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_mod_1_acalcvm(self):
		"""Test acalcvm mod  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat(-2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mod_1_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat(-2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mod_1_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat(-2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mod_1_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat(-2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_mod_2_acalcvm(self):
		"""Test acalcvm mod  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mod_2_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mod_2_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mod_2_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_mod_3_acalcvm(self):
		"""Test acalcvm mod  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mod_3_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mod_3_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mod_3_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_mod_4_acalcvm(self):
		"""Test acalcvm mod  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mod_4_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mod_4_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mod_4_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_uadd_1_acalcvm(self):
		"""Test acalcvm uadd  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [+x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_uadd_1_acalcvm_ov(self):
		"""Test acalcvm uadd with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [+x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_uadd_1_acalcvm_lim(self):
		"""Test acalcvm uadd with array limit  - Array code f.
		"""
		data = array.array('f', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [+x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_uadd_1_acalcvm_ov_lim(self):
		"""Test acalcvm uadd with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [+x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_usub_1_acalcvm(self):
		"""Test acalcvm usub  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [-x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_usub_1_acalcvm_ov(self):
		"""Test acalcvm usub with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [-x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_usub_1_acalcvm_lim(self):
		"""Test acalcvm usub with array limit  - Array code f.
		"""
		data = array.array('f', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [-x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_usub_1_acalcvm_ov_lim(self):
		"""Test acalcvm usub with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [-x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_pow_1_acalcvm(self):
		"""Test acalcvm pow  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat(0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_pow_1_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat(0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_pow_1_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat(0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_pow_1_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat(0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_pow_2_acalcvm(self):
		"""Test acalcvm pow  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_pow_2_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_pow_2_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_pow_2_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_pow_3_acalcvm(self):
		"""Test acalcvm pow  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_pow_3_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_pow_3_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_pow_3_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_abs_1_acalcvm(self):
		"""Test acalcvm abs  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [abs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_abs_1_acalcvm_ov(self):
		"""Test acalcvm abs with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [abs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_abs_1_acalcvm_lim(self):
		"""Test acalcvm abs with array limit  - Array code f.
		"""
		data = array.array('f', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [abs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_abs_1_acalcvm_ov_lim(self):
		"""Test acalcvm abs with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [abs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_acos_1_acalcvm(self):
		"""Test acalcvm math_acos  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.acos(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.acos(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_acos_1_acalcvm_ov(self):
		"""Test acalcvm math_acos with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.acos(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.acos(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_acos_1_acalcvm_lim(self):
		"""Test acalcvm math_acos with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.acos(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.acos(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_acos_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_acos with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.acos(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.acos(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_acosh_1_acalcvm(self):
		"""Test acalcvm math_acosh  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.acosh(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.acosh(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_acosh_1_acalcvm_ov(self):
		"""Test acalcvm math_acosh with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.acosh(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.acosh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_acosh_1_acalcvm_lim(self):
		"""Test acalcvm math_acosh with array limit  - Array code f.
		"""
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.acosh(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.acosh(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_acosh_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_acosh with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.acosh(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.acosh(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_asin_1_acalcvm(self):
		"""Test acalcvm math_asin  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.asin(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.asin(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_asin_1_acalcvm_ov(self):
		"""Test acalcvm math_asin with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.asin(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.asin(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_asin_1_acalcvm_lim(self):
		"""Test acalcvm math_asin with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.asin(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.asin(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_asin_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_asin with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.asin(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.asin(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_asinh_1_acalcvm(self):
		"""Test acalcvm math_asinh  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.asinh(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.asinh(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_asinh_1_acalcvm_ov(self):
		"""Test acalcvm math_asinh with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.asinh(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.asinh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_asinh_1_acalcvm_lim(self):
		"""Test acalcvm math_asinh with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.asinh(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.asinh(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_asinh_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_asinh with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.asinh(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.asinh(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_atan_1_acalcvm(self):
		"""Test acalcvm math_atan  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.atan(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan_1_acalcvm_ov(self):
		"""Test acalcvm math_atan with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.atan(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan_1_acalcvm_lim(self):
		"""Test acalcvm math_atan with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.atan(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_atan with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.atan(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_atan2_1_acalcvm(self):
		"""Test acalcvm math_atan2  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat(-2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_1_acalcvm_ov(self):
		"""Test acalcvm math_atan2 with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat(-2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_1_acalcvm_lim(self):
		"""Test acalcvm math_atan2 with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat(-2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_atan2 with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat(-2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_atan2_2_acalcvm(self):
		"""Test acalcvm math_atan2  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_2_acalcvm_ov(self):
		"""Test acalcvm math_atan2 with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_2_acalcvm_lim(self):
		"""Test acalcvm math_atan2 with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_2_acalcvm_ov_lim(self):
		"""Test acalcvm math_atan2 with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_atan2_3_acalcvm(self):
		"""Test acalcvm math_atan2  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( 0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_3_acalcvm_ov(self):
		"""Test acalcvm math_atan2 with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( 0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_3_acalcvm_lim(self):
		"""Test acalcvm math_atan2 with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( 0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_3_acalcvm_ov_lim(self):
		"""Test acalcvm math_atan2 with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( 0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_atan2_4_acalcvm(self):
		"""Test acalcvm math_atan2  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_4_acalcvm_ov(self):
		"""Test acalcvm math_atan2 with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_4_acalcvm_lim(self):
		"""Test acalcvm math_atan2 with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_4_acalcvm_ov_lim(self):
		"""Test acalcvm math_atan2 with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_atan2_5_acalcvm(self):
		"""Test acalcvm math_atan2  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_5_acalcvm_ov(self):
		"""Test acalcvm math_atan2 with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_5_acalcvm_lim(self):
		"""Test acalcvm math_atan2 with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_5_acalcvm_ov_lim(self):
		"""Test acalcvm math_atan2 with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_atanh_1_acalcvm(self):
		"""Test acalcvm math_atanh  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.atanh(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atanh(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atanh_1_acalcvm_ov(self):
		"""Test acalcvm math_atanh with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.atanh(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atanh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atanh_1_acalcvm_lim(self):
		"""Test acalcvm math_atanh with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.atanh(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atanh(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atanh_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_atanh with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.atanh(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atanh(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_ceil_1_acalcvm(self):
		"""Test acalcvm math_ceil  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [0.0,0.4,0.8,1.2,1.6,2.0,2.4,2.8,3.2,3.6])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.ceil(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ceil(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ceil_1_acalcvm_ov(self):
		"""Test acalcvm math_ceil with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,0.4,0.8,1.2,1.6,2.0,2.4,2.8,3.2,3.6])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.ceil(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ceil(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ceil_1_acalcvm_lim(self):
		"""Test acalcvm math_ceil with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,0.4,0.8,1.2,1.6,2.0,2.4,2.8,3.2,3.6])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.ceil(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ceil(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ceil_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_ceil with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,0.4,0.8,1.2,1.6,2.0,2.4,2.8,3.2,3.6])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.ceil(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ceil(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_copysign_1_acalcvm(self):
		"""Test acalcvm math_copysign  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat(-3.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([-3.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_1_acalcvm_ov(self):
		"""Test acalcvm math_copysign with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat(-3.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([-3.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_1_acalcvm_lim(self):
		"""Test acalcvm math_copysign with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat(-3.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([-3.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_copysign with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat(-3.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([-3.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_copysign_2_acalcvm(self):
		"""Test acalcvm math_copysign  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_2_acalcvm_ov(self):
		"""Test acalcvm math_copysign with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_2_acalcvm_lim(self):
		"""Test acalcvm math_copysign with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_2_acalcvm_ov_lim(self):
		"""Test acalcvm math_copysign with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_copysign_3_acalcvm(self):
		"""Test acalcvm math_copysign  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( 0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_3_acalcvm_ov(self):
		"""Test acalcvm math_copysign with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( 0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_3_acalcvm_lim(self):
		"""Test acalcvm math_copysign with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( 0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_3_acalcvm_ov_lim(self):
		"""Test acalcvm math_copysign with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( 0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_copysign_4_acalcvm(self):
		"""Test acalcvm math_copysign  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_4_acalcvm_ov(self):
		"""Test acalcvm math_copysign with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_4_acalcvm_lim(self):
		"""Test acalcvm math_copysign with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_4_acalcvm_ov_lim(self):
		"""Test acalcvm math_copysign with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_copysign_5_acalcvm(self):
		"""Test acalcvm math_copysign  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( 3.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 3.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_5_acalcvm_ov(self):
		"""Test acalcvm math_copysign with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( 3.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 3.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_5_acalcvm_lim(self):
		"""Test acalcvm math_copysign with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( 3.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 3.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_5_acalcvm_ov_lim(self):
		"""Test acalcvm math_copysign with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( 3.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 3.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_cos_1_acalcvm(self):
		"""Test acalcvm math_cos  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.cos(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.cos(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_cos_1_acalcvm_ov(self):
		"""Test acalcvm math_cos with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.cos(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.cos(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_cos_1_acalcvm_lim(self):
		"""Test acalcvm math_cos with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.cos(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.cos(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_cos_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_cos with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.cos(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.cos(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_cosh_1_acalcvm(self):
		"""Test acalcvm math_cosh  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.cosh(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.cosh(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_cosh_1_acalcvm_ov(self):
		"""Test acalcvm math_cosh with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.cosh(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.cosh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_cosh_1_acalcvm_lim(self):
		"""Test acalcvm math_cosh with array limit  - Array code f.
		"""
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.cosh(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.cosh(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_cosh_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_cosh with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.cosh(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.cosh(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_degrees_1_acalcvm(self):
		"""Test acalcvm math_degrees  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.degrees(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.degrees(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_degrees_1_acalcvm_ov(self):
		"""Test acalcvm math_degrees with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.degrees(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.degrees(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_degrees_1_acalcvm_lim(self):
		"""Test acalcvm math_degrees with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.degrees(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.degrees(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_degrees_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_degrees with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.degrees(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.degrees(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_erf_1_acalcvm(self):
		"""Test acalcvm math_erf  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.erf(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.erf(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_erf_1_acalcvm_ov(self):
		"""Test acalcvm math_erf with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.erf(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.erf(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_erf_1_acalcvm_lim(self):
		"""Test acalcvm math_erf with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.erf(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.erf(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_erf_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_erf with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.erf(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.erf(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_erfc_1_acalcvm(self):
		"""Test acalcvm math_erfc  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.erfc(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.erfc(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_erfc_1_acalcvm_ov(self):
		"""Test acalcvm math_erfc with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.erfc(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.erfc(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_erfc_1_acalcvm_lim(self):
		"""Test acalcvm math_erfc with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.erfc(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.erfc(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_erfc_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_erfc with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.erfc(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.erfc(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_exp_1_acalcvm(self):
		"""Test acalcvm math_exp  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.exp(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.exp(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_exp_1_acalcvm_ov(self):
		"""Test acalcvm math_exp with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.exp(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.exp(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_exp_1_acalcvm_lim(self):
		"""Test acalcvm math_exp with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.exp(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.exp(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_exp_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_exp with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.exp(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.exp(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_expm1_1_acalcvm(self):
		"""Test acalcvm math_expm1  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.expm1(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.expm1(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_expm1_1_acalcvm_ov(self):
		"""Test acalcvm math_expm1 with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.expm1(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.expm1(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_expm1_1_acalcvm_lim(self):
		"""Test acalcvm math_expm1 with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.expm1(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.expm1(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_expm1_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_expm1 with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.expm1(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.expm1(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_fabs_1_acalcvm(self):
		"""Test acalcvm math_fabs  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.fabs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fabs(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fabs_1_acalcvm_ov(self):
		"""Test acalcvm math_fabs with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.fabs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fabs(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fabs_1_acalcvm_lim(self):
		"""Test acalcvm math_fabs with array limit  - Array code f.
		"""
		data = array.array('f', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.fabs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fabs(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fabs_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_fabs with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.fabs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fabs(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_floor_1_acalcvm(self):
		"""Test acalcvm math_floor  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [0.0,0.4,0.8,1.2,1.6,2.0,2.4,2.8,3.2,3.6])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.floor(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.floor(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_floor_1_acalcvm_ov(self):
		"""Test acalcvm math_floor with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,0.4,0.8,1.2,1.6,2.0,2.4,2.8,3.2,3.6])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.floor(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.floor(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_floor_1_acalcvm_lim(self):
		"""Test acalcvm math_floor with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,0.4,0.8,1.2,1.6,2.0,2.4,2.8,3.2,3.6])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.floor(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.floor(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_floor_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_floor with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,0.4,0.8,1.2,1.6,2.0,2.4,2.8,3.2,3.6])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.floor(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.floor(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_fmod_1_acalcvm(self):
		"""Test acalcvm math_fmod  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat(-2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fmod_1_acalcvm_ov(self):
		"""Test acalcvm math_fmod with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat(-2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fmod_1_acalcvm_lim(self):
		"""Test acalcvm math_fmod with array limit  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat(-2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fmod_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_fmod with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat(-2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_fmod_2_acalcvm(self):
		"""Test acalcvm math_fmod  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fmod_2_acalcvm_ov(self):
		"""Test acalcvm math_fmod with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fmod_2_acalcvm_lim(self):
		"""Test acalcvm math_fmod with array limit  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fmod_2_acalcvm_ov_lim(self):
		"""Test acalcvm math_fmod with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_fmod_3_acalcvm(self):
		"""Test acalcvm math_fmod  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fmod_3_acalcvm_ov(self):
		"""Test acalcvm math_fmod with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fmod_3_acalcvm_lim(self):
		"""Test acalcvm math_fmod with array limit  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fmod_3_acalcvm_ov_lim(self):
		"""Test acalcvm math_fmod with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_fmod_4_acalcvm(self):
		"""Test acalcvm math_fmod  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fmod_4_acalcvm_ov(self):
		"""Test acalcvm math_fmod with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fmod_4_acalcvm_lim(self):
		"""Test acalcvm math_fmod with array limit  - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fmod_4_acalcvm_ov_lim(self):
		"""Test acalcvm math_fmod with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_gamma_1_acalcvm(self):
		"""Test acalcvm math_gamma  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.gamma(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.gamma(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_gamma_1_acalcvm_ov(self):
		"""Test acalcvm math_gamma with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.gamma(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.gamma(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_gamma_1_acalcvm_lim(self):
		"""Test acalcvm math_gamma with array limit  - Array code f.
		"""
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.gamma(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.gamma(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_gamma_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_gamma with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.gamma(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.gamma(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_hypot_1_acalcvm(self):
		"""Test acalcvm math_hypot  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat(-2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_1_acalcvm_ov(self):
		"""Test acalcvm math_hypot with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat(-2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_1_acalcvm_lim(self):
		"""Test acalcvm math_hypot with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat(-2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_hypot with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat(-2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_hypot_2_acalcvm(self):
		"""Test acalcvm math_hypot  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_2_acalcvm_ov(self):
		"""Test acalcvm math_hypot with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_2_acalcvm_lim(self):
		"""Test acalcvm math_hypot with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_2_acalcvm_ov_lim(self):
		"""Test acalcvm math_hypot with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_hypot_3_acalcvm(self):
		"""Test acalcvm math_hypot  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( 0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_3_acalcvm_ov(self):
		"""Test acalcvm math_hypot with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( 0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_3_acalcvm_lim(self):
		"""Test acalcvm math_hypot with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( 0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_3_acalcvm_ov_lim(self):
		"""Test acalcvm math_hypot with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( 0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_hypot_4_acalcvm(self):
		"""Test acalcvm math_hypot  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_4_acalcvm_ov(self):
		"""Test acalcvm math_hypot with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_4_acalcvm_lim(self):
		"""Test acalcvm math_hypot with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_4_acalcvm_ov_lim(self):
		"""Test acalcvm math_hypot with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_hypot_5_acalcvm(self):
		"""Test acalcvm math_hypot  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_5_acalcvm_ov(self):
		"""Test acalcvm math_hypot with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_5_acalcvm_lim(self):
		"""Test acalcvm math_hypot with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_5_acalcvm_ov_lim(self):
		"""Test acalcvm math_hypot with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_ldexp_1_acalcvm(self):
		"""Test acalcvm math_ldexp  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([-2], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_1_acalcvm_ov(self):
		"""Test acalcvm math_ldexp with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([-2], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_1_acalcvm_lim(self):
		"""Test acalcvm math_ldexp with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([-2], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_ldexp with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([-2], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_ldexp_2_acalcvm(self):
		"""Test acalcvm math_ldexp  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ -1], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_2_acalcvm_ov(self):
		"""Test acalcvm math_ldexp with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_2_acalcvm_lim(self):
		"""Test acalcvm math_ldexp with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ -1], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_2_acalcvm_ov_lim(self):
		"""Test acalcvm math_ldexp with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_ldexp_3_acalcvm(self):
		"""Test acalcvm math_ldexp  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_3_acalcvm_ov(self):
		"""Test acalcvm math_ldexp with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_3_acalcvm_lim(self):
		"""Test acalcvm math_ldexp with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_3_acalcvm_ov_lim(self):
		"""Test acalcvm math_ldexp with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_ldexp_4_acalcvm(self):
		"""Test acalcvm math_ldexp  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_4_acalcvm_ov(self):
		"""Test acalcvm math_ldexp with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_4_acalcvm_lim(self):
		"""Test acalcvm math_ldexp with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_4_acalcvm_ov_lim(self):
		"""Test acalcvm math_ldexp with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_ldexp_5_acalcvm(self):
		"""Test acalcvm math_ldexp  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_5_acalcvm_ov(self):
		"""Test acalcvm math_ldexp with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_5_acalcvm_lim(self):
		"""Test acalcvm math_ldexp with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_5_acalcvm_ov_lim(self):
		"""Test acalcvm math_ldexp with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_lgamma_1_acalcvm(self):
		"""Test acalcvm math_lgamma  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.lgamma(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.lgamma(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_lgamma_1_acalcvm_ov(self):
		"""Test acalcvm math_lgamma with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.lgamma(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.lgamma(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_lgamma_1_acalcvm_lim(self):
		"""Test acalcvm math_lgamma with array limit  - Array code f.
		"""
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.lgamma(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.lgamma(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_lgamma_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_lgamma with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.lgamma(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.lgamma(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_log_1_acalcvm(self):
		"""Test acalcvm math_log  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.log(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_log_1_acalcvm_ov(self):
		"""Test acalcvm math_log with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.log(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_log_1_acalcvm_lim(self):
		"""Test acalcvm math_log with array limit  - Array code f.
		"""
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.log(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_log_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_log with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.log(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_log10_1_acalcvm(self):
		"""Test acalcvm math_log10  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.log10(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log10(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_log10_1_acalcvm_ov(self):
		"""Test acalcvm math_log10 with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.log10(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log10(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_log10_1_acalcvm_lim(self):
		"""Test acalcvm math_log10 with array limit  - Array code f.
		"""
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.log10(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log10(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_log10_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_log10 with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.log10(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log10(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_log1p_1_acalcvm(self):
		"""Test acalcvm math_log1p  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.log1p(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log1p(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_log1p_1_acalcvm_ov(self):
		"""Test acalcvm math_log1p with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.log1p(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log1p(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_log1p_1_acalcvm_lim(self):
		"""Test acalcvm math_log1p with array limit  - Array code f.
		"""
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.log1p(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log1p(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_log1p_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_log1p with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.log1p(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log1p(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_log2_1_acalcvm(self):
		"""Test acalcvm math_log2  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.log2(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log2(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_log2_1_acalcvm_ov(self):
		"""Test acalcvm math_log2 with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.log2(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log2(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_log2_1_acalcvm_lim(self):
		"""Test acalcvm math_log2 with array limit  - Array code f.
		"""
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.log2(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log2(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_log2_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_log2 with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.log2(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log2(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_pow_1_acalcvm(self):
		"""Test acalcvm math_pow  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.pow(x, y) for x,y in zip(list(data), itertools.repeat(0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([0.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_pow_1_acalcvm_ov(self):
		"""Test acalcvm math_pow with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.pow(x, y) for x,y in zip(list(data), itertools.repeat(0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([0.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_pow_1_acalcvm_lim(self):
		"""Test acalcvm math_pow with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.pow(x, y) for x,y in zip(list(data), itertools.repeat(0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([0.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_pow_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_pow with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.pow(x, y) for x,y in zip(list(data), itertools.repeat(0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([0.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_pow_2_acalcvm(self):
		"""Test acalcvm math_pow  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.pow(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_pow_2_acalcvm_ov(self):
		"""Test acalcvm math_pow with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.pow(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_pow_2_acalcvm_lim(self):
		"""Test acalcvm math_pow with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.pow(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_pow_2_acalcvm_ov_lim(self):
		"""Test acalcvm math_pow with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.pow(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_pow_3_acalcvm(self):
		"""Test acalcvm math_pow  - Array code f.
		"""
		# Template name: test_template_2ops
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.pow(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_pow_3_acalcvm_ov(self):
		"""Test acalcvm math_pow with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.pow(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_pow_3_acalcvm_lim(self):
		"""Test acalcvm math_pow with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.pow(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_pow_3_acalcvm_ov_lim(self):
		"""Test acalcvm math_pow with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.pow(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_radians_1_acalcvm(self):
		"""Test acalcvm math_radians  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.radians(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.radians(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_radians_1_acalcvm_ov(self):
		"""Test acalcvm math_radians with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.radians(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.radians(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_radians_1_acalcvm_lim(self):
		"""Test acalcvm math_radians with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.radians(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.radians(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_radians_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_radians with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.radians(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.radians(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_sin_1_acalcvm(self):
		"""Test acalcvm math_sin  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.sin(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.sin(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_sin_1_acalcvm_ov(self):
		"""Test acalcvm math_sin with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.sin(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.sin(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_sin_1_acalcvm_lim(self):
		"""Test acalcvm math_sin with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.sin(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.sin(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_sin_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_sin with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.sin(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.sin(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_sinh_1_acalcvm(self):
		"""Test acalcvm math_sinh  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.sinh(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.sinh(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_sinh_1_acalcvm_ov(self):
		"""Test acalcvm math_sinh with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.sinh(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.sinh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_sinh_1_acalcvm_lim(self):
		"""Test acalcvm math_sinh with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.sinh(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.sinh(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_sinh_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_sinh with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.sinh(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.sinh(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_sqrt_1_acalcvm(self):
		"""Test acalcvm math_sqrt  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.sqrt(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.sqrt(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_sqrt_1_acalcvm_ov(self):
		"""Test acalcvm math_sqrt with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.sqrt(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.sqrt(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_sqrt_1_acalcvm_lim(self):
		"""Test acalcvm math_sqrt with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.sqrt(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.sqrt(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_sqrt_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_sqrt with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.sqrt(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.sqrt(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_tan_1_acalcvm(self):
		"""Test acalcvm math_tan  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.tan(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.tan(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_tan_1_acalcvm_ov(self):
		"""Test acalcvm math_tan with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.tan(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.tan(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_tan_1_acalcvm_lim(self):
		"""Test acalcvm math_tan with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.tan(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.tan(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_tan_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_tan with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.tan(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.tan(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_tanh_1_acalcvm(self):
		"""Test acalcvm math_tanh  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.tanh(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.tanh(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_tanh_1_acalcvm_ov(self):
		"""Test acalcvm math_tanh with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.tanh(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.tanh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_tanh_1_acalcvm_lim(self):
		"""Test acalcvm math_tanh with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.tanh(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.tanh(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_tanh_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_tanh with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.tanh(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.tanh(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_trunc_1_acalcvm(self):
		"""Test acalcvm math_trunc  - Array code f.
		"""
		# Template name: test_template_1op
		data = array.array('f', [0.0,2.4,4.8,7.2,9.6,12.0,14.4,16.8,19.2,21.6])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.trunc(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.trunc(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_trunc_1_acalcvm_ov(self):
		"""Test acalcvm math_trunc with overflow checking disabled  - Array code f.
		"""
		data = array.array('f', [0.0,2.4,4.8,7.2,9.6,12.0,14.4,16.8,19.2,21.6])
		
		dataout = array.array('f', [0]*len(data))
		

		expected = [math.trunc(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.trunc(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_trunc_1_acalcvm_lim(self):
		"""Test acalcvm math_trunc with array limit  - Array code f.
		"""
		data = array.array('f', [0.0,2.4,4.8,7.2,9.6,12.0,14.4,16.8,19.2,21.6])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.trunc(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.trunc(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_trunc_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_trunc with overflow checking disabled and array limit - Array code f.
		"""
		data = array.array('f', [0.0,2.4,4.8,7.2,9.6,12.0,14.4,16.8,19.2,21.6])
		
		dataout = array.array('f', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.trunc(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.trunc(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



##############################################################################

##############################################################################
class acalcvm_operator_d(unittest.TestCase):
	"""Test for basic operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'd'


	########################################################
	def test_operator_add_1_acalcvm(self):
		"""Test acalcvm add  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat(-25.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_1_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat(-25.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_1_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat(-25.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_1_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat(-25.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_add_2_acalcvm(self):
		"""Test acalcvm add  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_2_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_2_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_2_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_add_3_acalcvm(self):
		"""Test acalcvm add  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_3_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_3_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_3_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_add_4_acalcvm(self):
		"""Test acalcvm add  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_4_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_4_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_4_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_add_5_acalcvm(self):
		"""Test acalcvm add  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 25.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_5_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 25.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_5_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 25.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_add_5_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 25.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_sub_1_acalcvm(self):
		"""Test acalcvm sub  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat(-2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_1_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat(-2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_1_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat(-2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_1_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat(-2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_sub_2_acalcvm(self):
		"""Test acalcvm sub  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_2_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_2_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_2_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_sub_3_acalcvm(self):
		"""Test acalcvm sub  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_3_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_3_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_3_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_sub_4_acalcvm(self):
		"""Test acalcvm sub  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_4_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_4_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_4_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_sub_5_acalcvm(self):
		"""Test acalcvm sub  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_5_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_5_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_sub_5_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_mult_1_acalcvm(self):
		"""Test acalcvm mult  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat(-3.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_1_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat(-3.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_1_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat(-3.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_1_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat(-3.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_mult_2_acalcvm(self):
		"""Test acalcvm mult  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( -2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_2_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( -2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_2_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( -2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_2_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( -2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_mult_3_acalcvm(self):
		"""Test acalcvm mult  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_3_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_3_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_3_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_mult_4_acalcvm(self):
		"""Test acalcvm mult  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_4_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_4_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_4_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_mult_5_acalcvm(self):
		"""Test acalcvm mult  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_5_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_5_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_5_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_mult_6_acalcvm(self):
		"""Test acalcvm mult  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_6_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_6_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_6_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_mult_7_acalcvm(self):
		"""Test acalcvm mult  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 3.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_7_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 3.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_7_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 3.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mult_7_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 3.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_div_1_acalcvm(self):
		"""Test acalcvm div  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x / y for x,y in zip(list(data), itertools.repeat(-2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_div_1_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x / y for x,y in zip(list(data), itertools.repeat(-2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_div_1_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x / y for x,y in zip(list(data), itertools.repeat(-2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_div_1_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x / y for x,y in zip(list(data), itertools.repeat(-2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_div_2_acalcvm(self):
		"""Test acalcvm div  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x / y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_div_2_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x / y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_div_2_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x / y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_div_2_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x / y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_div_3_acalcvm(self):
		"""Test acalcvm div  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x / y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_div_3_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x / y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_div_3_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x / y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_div_3_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x / y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_div_4_acalcvm(self):
		"""Test acalcvm div  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x / y for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_div_4_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x / y for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_div_4_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x / y for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_div_4_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x / y for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_floordiv_1_acalcvm(self):
		"""Test acalcvm floordiv  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat(-2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_floordiv_1_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat(-2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_floordiv_1_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat(-2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_floordiv_1_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat(-2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_floordiv_2_acalcvm(self):
		"""Test acalcvm floordiv  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_floordiv_2_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_floordiv_2_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_floordiv_2_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_floordiv_3_acalcvm(self):
		"""Test acalcvm floordiv  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_floordiv_3_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_floordiv_3_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_floordiv_3_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_floordiv_4_acalcvm(self):
		"""Test acalcvm floordiv  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_floordiv_4_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_floordiv_4_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_floordiv_4_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_mod_1_acalcvm(self):
		"""Test acalcvm mod  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat(-2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mod_1_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat(-2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mod_1_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat(-2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mod_1_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat(-2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_mod_2_acalcvm(self):
		"""Test acalcvm mod  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mod_2_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mod_2_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mod_2_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_mod_3_acalcvm(self):
		"""Test acalcvm mod  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mod_3_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mod_3_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mod_3_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_mod_4_acalcvm(self):
		"""Test acalcvm mod  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mod_4_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mod_4_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_mod_4_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_uadd_1_acalcvm(self):
		"""Test acalcvm uadd  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [+x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_uadd_1_acalcvm_ov(self):
		"""Test acalcvm uadd with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [+x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_uadd_1_acalcvm_lim(self):
		"""Test acalcvm uadd with array limit  - Array code d.
		"""
		data = array.array('d', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [+x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_uadd_1_acalcvm_ov_lim(self):
		"""Test acalcvm uadd with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [+x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_usub_1_acalcvm(self):
		"""Test acalcvm usub  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [-x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_usub_1_acalcvm_ov(self):
		"""Test acalcvm usub with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [-x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_usub_1_acalcvm_lim(self):
		"""Test acalcvm usub with array limit  - Array code d.
		"""
		data = array.array('d', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [-x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_usub_1_acalcvm_ov_lim(self):
		"""Test acalcvm usub with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [-x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_pow_1_acalcvm(self):
		"""Test acalcvm pow  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat(0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_pow_1_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat(0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_pow_1_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat(0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_pow_1_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat(0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_pow_2_acalcvm(self):
		"""Test acalcvm pow  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_pow_2_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_pow_2_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_pow_2_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_pow_3_acalcvm(self):
		"""Test acalcvm pow  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_pow_3_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_pow_3_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_pow_3_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_abs_1_acalcvm(self):
		"""Test acalcvm abs  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [abs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_abs_1_acalcvm_ov(self):
		"""Test acalcvm abs with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [abs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_abs_1_acalcvm_lim(self):
		"""Test acalcvm abs with array limit  - Array code d.
		"""
		data = array.array('d', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [abs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_abs_1_acalcvm_ov_lim(self):
		"""Test acalcvm abs with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [abs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_acos_1_acalcvm(self):
		"""Test acalcvm math_acos  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.acos(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.acos(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_acos_1_acalcvm_ov(self):
		"""Test acalcvm math_acos with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.acos(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.acos(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_acos_1_acalcvm_lim(self):
		"""Test acalcvm math_acos with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.acos(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.acos(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_acos_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_acos with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.acos(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.acos(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_acosh_1_acalcvm(self):
		"""Test acalcvm math_acosh  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.acosh(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.acosh(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_acosh_1_acalcvm_ov(self):
		"""Test acalcvm math_acosh with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.acosh(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.acosh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_acosh_1_acalcvm_lim(self):
		"""Test acalcvm math_acosh with array limit  - Array code d.
		"""
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.acosh(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.acosh(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_acosh_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_acosh with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.acosh(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.acosh(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_asin_1_acalcvm(self):
		"""Test acalcvm math_asin  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.asin(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.asin(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_asin_1_acalcvm_ov(self):
		"""Test acalcvm math_asin with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.asin(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.asin(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_asin_1_acalcvm_lim(self):
		"""Test acalcvm math_asin with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.asin(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.asin(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_asin_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_asin with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.asin(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.asin(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_asinh_1_acalcvm(self):
		"""Test acalcvm math_asinh  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.asinh(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.asinh(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_asinh_1_acalcvm_ov(self):
		"""Test acalcvm math_asinh with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.asinh(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.asinh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_asinh_1_acalcvm_lim(self):
		"""Test acalcvm math_asinh with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.asinh(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.asinh(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_asinh_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_asinh with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.asinh(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.asinh(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_atan_1_acalcvm(self):
		"""Test acalcvm math_atan  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.atan(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan_1_acalcvm_ov(self):
		"""Test acalcvm math_atan with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.atan(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan_1_acalcvm_lim(self):
		"""Test acalcvm math_atan with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.atan(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_atan with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.atan(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_atan2_1_acalcvm(self):
		"""Test acalcvm math_atan2  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat(-2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_1_acalcvm_ov(self):
		"""Test acalcvm math_atan2 with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat(-2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_1_acalcvm_lim(self):
		"""Test acalcvm math_atan2 with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat(-2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_atan2 with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat(-2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_atan2_2_acalcvm(self):
		"""Test acalcvm math_atan2  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_2_acalcvm_ov(self):
		"""Test acalcvm math_atan2 with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_2_acalcvm_lim(self):
		"""Test acalcvm math_atan2 with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_2_acalcvm_ov_lim(self):
		"""Test acalcvm math_atan2 with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_atan2_3_acalcvm(self):
		"""Test acalcvm math_atan2  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( 0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_3_acalcvm_ov(self):
		"""Test acalcvm math_atan2 with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( 0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_3_acalcvm_lim(self):
		"""Test acalcvm math_atan2 with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( 0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_3_acalcvm_ov_lim(self):
		"""Test acalcvm math_atan2 with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( 0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_atan2_4_acalcvm(self):
		"""Test acalcvm math_atan2  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_4_acalcvm_ov(self):
		"""Test acalcvm math_atan2 with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_4_acalcvm_lim(self):
		"""Test acalcvm math_atan2 with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_4_acalcvm_ov_lim(self):
		"""Test acalcvm math_atan2 with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_atan2_5_acalcvm(self):
		"""Test acalcvm math_atan2  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_5_acalcvm_ov(self):
		"""Test acalcvm math_atan2 with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_5_acalcvm_lim(self):
		"""Test acalcvm math_atan2 with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atan2_5_acalcvm_ov_lim(self):
		"""Test acalcvm math_atan2 with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.atan2(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_atanh_1_acalcvm(self):
		"""Test acalcvm math_atanh  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.atanh(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atanh(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atanh_1_acalcvm_ov(self):
		"""Test acalcvm math_atanh with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.atanh(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atanh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atanh_1_acalcvm_lim(self):
		"""Test acalcvm math_atanh with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.atanh(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atanh(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_atanh_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_atanh with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.atanh(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atanh(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_ceil_1_acalcvm(self):
		"""Test acalcvm math_ceil  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [0.0,0.4,0.8,1.2,1.6,2.0,2.4,2.8,3.2,3.6])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.ceil(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ceil(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ceil_1_acalcvm_ov(self):
		"""Test acalcvm math_ceil with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,0.4,0.8,1.2,1.6,2.0,2.4,2.8,3.2,3.6])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.ceil(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ceil(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ceil_1_acalcvm_lim(self):
		"""Test acalcvm math_ceil with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,0.4,0.8,1.2,1.6,2.0,2.4,2.8,3.2,3.6])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.ceil(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ceil(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ceil_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_ceil with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,0.4,0.8,1.2,1.6,2.0,2.4,2.8,3.2,3.6])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.ceil(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ceil(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_copysign_1_acalcvm(self):
		"""Test acalcvm math_copysign  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat(-3.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([-3.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_1_acalcvm_ov(self):
		"""Test acalcvm math_copysign with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat(-3.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([-3.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_1_acalcvm_lim(self):
		"""Test acalcvm math_copysign with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat(-3.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([-3.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_copysign with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat(-3.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([-3.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_copysign_2_acalcvm(self):
		"""Test acalcvm math_copysign  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_2_acalcvm_ov(self):
		"""Test acalcvm math_copysign with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_2_acalcvm_lim(self):
		"""Test acalcvm math_copysign with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_2_acalcvm_ov_lim(self):
		"""Test acalcvm math_copysign with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_copysign_3_acalcvm(self):
		"""Test acalcvm math_copysign  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( 0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_3_acalcvm_ov(self):
		"""Test acalcvm math_copysign with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( 0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_3_acalcvm_lim(self):
		"""Test acalcvm math_copysign with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( 0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_3_acalcvm_ov_lim(self):
		"""Test acalcvm math_copysign with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( 0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_copysign_4_acalcvm(self):
		"""Test acalcvm math_copysign  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_4_acalcvm_ov(self):
		"""Test acalcvm math_copysign with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_4_acalcvm_lim(self):
		"""Test acalcvm math_copysign with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_4_acalcvm_ov_lim(self):
		"""Test acalcvm math_copysign with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_copysign_5_acalcvm(self):
		"""Test acalcvm math_copysign  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( 3.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 3.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_5_acalcvm_ov(self):
		"""Test acalcvm math_copysign with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( 3.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 3.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_5_acalcvm_lim(self):
		"""Test acalcvm math_copysign with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( 3.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 3.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_copysign_5_acalcvm_ov_lim(self):
		"""Test acalcvm math_copysign with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.copysign(x, y) for x,y in zip(list(data), itertools.repeat( 3.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 3.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_cos_1_acalcvm(self):
		"""Test acalcvm math_cos  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.cos(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.cos(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_cos_1_acalcvm_ov(self):
		"""Test acalcvm math_cos with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.cos(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.cos(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_cos_1_acalcvm_lim(self):
		"""Test acalcvm math_cos with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.cos(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.cos(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_cos_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_cos with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.cos(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.cos(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_cosh_1_acalcvm(self):
		"""Test acalcvm math_cosh  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.cosh(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.cosh(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_cosh_1_acalcvm_ov(self):
		"""Test acalcvm math_cosh with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.cosh(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.cosh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_cosh_1_acalcvm_lim(self):
		"""Test acalcvm math_cosh with array limit  - Array code d.
		"""
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.cosh(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.cosh(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_cosh_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_cosh with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.cosh(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.cosh(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_degrees_1_acalcvm(self):
		"""Test acalcvm math_degrees  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.degrees(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.degrees(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_degrees_1_acalcvm_ov(self):
		"""Test acalcvm math_degrees with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.degrees(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.degrees(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_degrees_1_acalcvm_lim(self):
		"""Test acalcvm math_degrees with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.degrees(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.degrees(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_degrees_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_degrees with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.degrees(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.degrees(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_erf_1_acalcvm(self):
		"""Test acalcvm math_erf  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.erf(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.erf(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_erf_1_acalcvm_ov(self):
		"""Test acalcvm math_erf with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.erf(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.erf(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_erf_1_acalcvm_lim(self):
		"""Test acalcvm math_erf with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.erf(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.erf(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_erf_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_erf with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.erf(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.erf(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_erfc_1_acalcvm(self):
		"""Test acalcvm math_erfc  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.erfc(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.erfc(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_erfc_1_acalcvm_ov(self):
		"""Test acalcvm math_erfc with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.erfc(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.erfc(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_erfc_1_acalcvm_lim(self):
		"""Test acalcvm math_erfc with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.erfc(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.erfc(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_erfc_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_erfc with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.erfc(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.erfc(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_exp_1_acalcvm(self):
		"""Test acalcvm math_exp  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.exp(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.exp(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_exp_1_acalcvm_ov(self):
		"""Test acalcvm math_exp with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.exp(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.exp(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_exp_1_acalcvm_lim(self):
		"""Test acalcvm math_exp with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.exp(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.exp(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_exp_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_exp with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.exp(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.exp(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_expm1_1_acalcvm(self):
		"""Test acalcvm math_expm1  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.expm1(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.expm1(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_expm1_1_acalcvm_ov(self):
		"""Test acalcvm math_expm1 with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.expm1(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.expm1(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_expm1_1_acalcvm_lim(self):
		"""Test acalcvm math_expm1 with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.expm1(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.expm1(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_expm1_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_expm1 with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.expm1(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.expm1(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_fabs_1_acalcvm(self):
		"""Test acalcvm math_fabs  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.fabs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fabs(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fabs_1_acalcvm_ov(self):
		"""Test acalcvm math_fabs with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.fabs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fabs(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fabs_1_acalcvm_lim(self):
		"""Test acalcvm math_fabs with array limit  - Array code d.
		"""
		data = array.array('d', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.fabs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fabs(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fabs_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_fabs with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.fabs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fabs(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_floor_1_acalcvm(self):
		"""Test acalcvm math_floor  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [0.0,0.4,0.8,1.2,1.6,2.0,2.4,2.8,3.2,3.6])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.floor(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.floor(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_floor_1_acalcvm_ov(self):
		"""Test acalcvm math_floor with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,0.4,0.8,1.2,1.6,2.0,2.4,2.8,3.2,3.6])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.floor(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.floor(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_floor_1_acalcvm_lim(self):
		"""Test acalcvm math_floor with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,0.4,0.8,1.2,1.6,2.0,2.4,2.8,3.2,3.6])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.floor(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.floor(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_floor_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_floor with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,0.4,0.8,1.2,1.6,2.0,2.4,2.8,3.2,3.6])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.floor(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.floor(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_fmod_1_acalcvm(self):
		"""Test acalcvm math_fmod  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat(-2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fmod_1_acalcvm_ov(self):
		"""Test acalcvm math_fmod with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat(-2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fmod_1_acalcvm_lim(self):
		"""Test acalcvm math_fmod with array limit  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat(-2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fmod_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_fmod with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat(-2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_fmod_2_acalcvm(self):
		"""Test acalcvm math_fmod  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fmod_2_acalcvm_ov(self):
		"""Test acalcvm math_fmod with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fmod_2_acalcvm_lim(self):
		"""Test acalcvm math_fmod with array limit  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fmod_2_acalcvm_ov_lim(self):
		"""Test acalcvm math_fmod with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_fmod_3_acalcvm(self):
		"""Test acalcvm math_fmod  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fmod_3_acalcvm_ov(self):
		"""Test acalcvm math_fmod with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fmod_3_acalcvm_lim(self):
		"""Test acalcvm math_fmod with array limit  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fmod_3_acalcvm_ov_lim(self):
		"""Test acalcvm math_fmod with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_fmod_4_acalcvm(self):
		"""Test acalcvm math_fmod  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fmod_4_acalcvm_ov(self):
		"""Test acalcvm math_fmod with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fmod_4_acalcvm_lim(self):
		"""Test acalcvm math_fmod with array limit  - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_fmod_4_acalcvm_ov_lim(self):
		"""Test acalcvm math_fmod with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.fmod(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_gamma_1_acalcvm(self):
		"""Test acalcvm math_gamma  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.gamma(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.gamma(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_gamma_1_acalcvm_ov(self):
		"""Test acalcvm math_gamma with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.gamma(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.gamma(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_gamma_1_acalcvm_lim(self):
		"""Test acalcvm math_gamma with array limit  - Array code d.
		"""
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.gamma(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.gamma(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_gamma_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_gamma with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.gamma(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.gamma(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_hypot_1_acalcvm(self):
		"""Test acalcvm math_hypot  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat(-2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_1_acalcvm_ov(self):
		"""Test acalcvm math_hypot with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat(-2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_1_acalcvm_lim(self):
		"""Test acalcvm math_hypot with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat(-2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_hypot with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat(-2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_hypot_2_acalcvm(self):
		"""Test acalcvm math_hypot  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_2_acalcvm_ov(self):
		"""Test acalcvm math_hypot with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_2_acalcvm_lim(self):
		"""Test acalcvm math_hypot with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_2_acalcvm_ov_lim(self):
		"""Test acalcvm math_hypot with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( -1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_hypot_3_acalcvm(self):
		"""Test acalcvm math_hypot  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( 0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_3_acalcvm_ov(self):
		"""Test acalcvm math_hypot with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( 0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_3_acalcvm_lim(self):
		"""Test acalcvm math_hypot with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( 0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_3_acalcvm_ov_lim(self):
		"""Test acalcvm math_hypot with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( 0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_hypot_4_acalcvm(self):
		"""Test acalcvm math_hypot  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_4_acalcvm_ov(self):
		"""Test acalcvm math_hypot with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_4_acalcvm_lim(self):
		"""Test acalcvm math_hypot with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_4_acalcvm_ov_lim(self):
		"""Test acalcvm math_hypot with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_hypot_5_acalcvm(self):
		"""Test acalcvm math_hypot  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_5_acalcvm_ov(self):
		"""Test acalcvm math_hypot with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_5_acalcvm_lim(self):
		"""Test acalcvm math_hypot with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_hypot_5_acalcvm_ov_lim(self):
		"""Test acalcvm math_hypot with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.hypot(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_ldexp_1_acalcvm(self):
		"""Test acalcvm math_ldexp  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([-2], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_1_acalcvm_ov(self):
		"""Test acalcvm math_ldexp with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat(-2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([-2], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_1_acalcvm_lim(self):
		"""Test acalcvm math_ldexp with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([-2], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_ldexp with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat(-2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([-2], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_ldexp_2_acalcvm(self):
		"""Test acalcvm math_ldexp  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ -1], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_2_acalcvm_ov(self):
		"""Test acalcvm math_ldexp with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( -1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_2_acalcvm_lim(self):
		"""Test acalcvm math_ldexp with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ -1], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_2_acalcvm_ov_lim(self):
		"""Test acalcvm math_ldexp with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( -1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_ldexp_3_acalcvm(self):
		"""Test acalcvm math_ldexp  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_3_acalcvm_ov(self):
		"""Test acalcvm math_ldexp with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( 0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_3_acalcvm_lim(self):
		"""Test acalcvm math_ldexp with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_3_acalcvm_ov_lim(self):
		"""Test acalcvm math_ldexp with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( 0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_ldexp_4_acalcvm(self):
		"""Test acalcvm math_ldexp  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_4_acalcvm_ov(self):
		"""Test acalcvm math_ldexp with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_4_acalcvm_lim(self):
		"""Test acalcvm math_ldexp with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_4_acalcvm_ov_lim(self):
		"""Test acalcvm math_ldexp with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_ldexp_5_acalcvm(self):
		"""Test acalcvm math_ldexp  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_5_acalcvm_ov(self):
		"""Test acalcvm math_ldexp with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_5_acalcvm_lim(self):
		"""Test acalcvm math_ldexp with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_ldexp_5_acalcvm_ov_lim(self):
		"""Test acalcvm math_ldexp with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.ldexp(x, y) for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_lgamma_1_acalcvm(self):
		"""Test acalcvm math_lgamma  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.lgamma(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.lgamma(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_lgamma_1_acalcvm_ov(self):
		"""Test acalcvm math_lgamma with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.lgamma(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.lgamma(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_lgamma_1_acalcvm_lim(self):
		"""Test acalcvm math_lgamma with array limit  - Array code d.
		"""
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.lgamma(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.lgamma(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_lgamma_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_lgamma with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.lgamma(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.lgamma(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_log_1_acalcvm(self):
		"""Test acalcvm math_log  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.log(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_log_1_acalcvm_ov(self):
		"""Test acalcvm math_log with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.log(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_log_1_acalcvm_lim(self):
		"""Test acalcvm math_log with array limit  - Array code d.
		"""
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.log(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_log_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_log with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.log(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_log10_1_acalcvm(self):
		"""Test acalcvm math_log10  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.log10(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log10(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_log10_1_acalcvm_ov(self):
		"""Test acalcvm math_log10 with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.log10(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log10(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_log10_1_acalcvm_lim(self):
		"""Test acalcvm math_log10 with array limit  - Array code d.
		"""
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.log10(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log10(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_log10_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_log10 with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.log10(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log10(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_log1p_1_acalcvm(self):
		"""Test acalcvm math_log1p  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.log1p(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log1p(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_log1p_1_acalcvm_ov(self):
		"""Test acalcvm math_log1p with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.log1p(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log1p(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_log1p_1_acalcvm_lim(self):
		"""Test acalcvm math_log1p with array limit  - Array code d.
		"""
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.log1p(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log1p(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_log1p_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_log1p with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.log1p(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log1p(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_log2_1_acalcvm(self):
		"""Test acalcvm math_log2  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.log2(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log2(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_log2_1_acalcvm_ov(self):
		"""Test acalcvm math_log2 with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.log2(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log2(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_log2_1_acalcvm_lim(self):
		"""Test acalcvm math_log2 with array limit  - Array code d.
		"""
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.log2(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log2(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_log2_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_log2 with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.log2(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log2(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_pow_1_acalcvm(self):
		"""Test acalcvm math_pow  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.pow(x, y) for x,y in zip(list(data), itertools.repeat(0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([0.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_pow_1_acalcvm_ov(self):
		"""Test acalcvm math_pow with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.pow(x, y) for x,y in zip(list(data), itertools.repeat(0.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([0.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_pow_1_acalcvm_lim(self):
		"""Test acalcvm math_pow with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.pow(x, y) for x,y in zip(list(data), itertools.repeat(0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([0.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_pow_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_pow with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.pow(x, y) for x,y in zip(list(data), itertools.repeat(0.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([0.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_pow_2_acalcvm(self):
		"""Test acalcvm math_pow  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.pow(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_pow_2_acalcvm_ov(self):
		"""Test acalcvm math_pow with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.pow(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_pow_2_acalcvm_lim(self):
		"""Test acalcvm math_pow with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.pow(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_pow_2_acalcvm_ov_lim(self):
		"""Test acalcvm math_pow with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.pow(x, y) for x,y in zip(list(data), itertools.repeat( 1.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_pow_3_acalcvm(self):
		"""Test acalcvm math_pow  - Array code d.
		"""
		# Template name: test_template_2ops
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.pow(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_pow_3_acalcvm_ov(self):
		"""Test acalcvm math_pow with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.pow(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_pow_3_acalcvm_lim(self):
		"""Test acalcvm math_pow with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.pow(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_pow_3_acalcvm_ov_lim(self):
		"""Test acalcvm math_pow with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.pow(x, y) for x,y in zip(list(data), itertools.repeat( 2.0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_radians_1_acalcvm(self):
		"""Test acalcvm math_radians  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.radians(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.radians(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_radians_1_acalcvm_ov(self):
		"""Test acalcvm math_radians with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.radians(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.radians(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_radians_1_acalcvm_lim(self):
		"""Test acalcvm math_radians with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.radians(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.radians(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_radians_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_radians with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.radians(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.radians(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_sin_1_acalcvm(self):
		"""Test acalcvm math_sin  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.sin(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.sin(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_sin_1_acalcvm_ov(self):
		"""Test acalcvm math_sin with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.sin(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.sin(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_sin_1_acalcvm_lim(self):
		"""Test acalcvm math_sin with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.sin(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.sin(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_sin_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_sin with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.sin(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.sin(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_sinh_1_acalcvm(self):
		"""Test acalcvm math_sinh  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.sinh(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.sinh(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_sinh_1_acalcvm_ov(self):
		"""Test acalcvm math_sinh with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.sinh(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.sinh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_sinh_1_acalcvm_lim(self):
		"""Test acalcvm math_sinh with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.sinh(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.sinh(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_sinh_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_sinh with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.sinh(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.sinh(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_sqrt_1_acalcvm(self):
		"""Test acalcvm math_sqrt  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.sqrt(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.sqrt(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_sqrt_1_acalcvm_ov(self):
		"""Test acalcvm math_sqrt with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.sqrt(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.sqrt(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_sqrt_1_acalcvm_lim(self):
		"""Test acalcvm math_sqrt with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.sqrt(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.sqrt(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_sqrt_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_sqrt with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.sqrt(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.sqrt(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_tan_1_acalcvm(self):
		"""Test acalcvm math_tan  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.tan(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.tan(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_tan_1_acalcvm_ov(self):
		"""Test acalcvm math_tan with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.tan(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.tan(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_tan_1_acalcvm_lim(self):
		"""Test acalcvm math_tan with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.tan(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.tan(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_tan_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_tan with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.tan(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.tan(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_tanh_1_acalcvm(self):
		"""Test acalcvm math_tanh  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.tanh(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.tanh(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_tanh_1_acalcvm_ov(self):
		"""Test acalcvm math_tanh with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.tanh(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.tanh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_tanh_1_acalcvm_lim(self):
		"""Test acalcvm math_tanh with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.tanh(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.tanh(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_tanh_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_tanh with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.tanh(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.tanh(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)




	########################################################
	def test_operator_math_trunc_1_acalcvm(self):
		"""Test acalcvm math_trunc  - Array code d.
		"""
		# Template name: test_template_1op
		data = array.array('d', [0.0,2.4,4.8,7.2,9.6,12.0,14.4,16.8,19.2,21.6])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.trunc(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.trunc(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_trunc_1_acalcvm_ov(self):
		"""Test acalcvm math_trunc with overflow checking disabled  - Array code d.
		"""
		data = array.array('d', [0.0,2.4,4.8,7.2,9.6,12.0,14.4,16.8,19.2,21.6])
		
		dataout = array.array('d', [0]*len(data))
		

		expected = [math.trunc(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.trunc(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_trunc_1_acalcvm_lim(self):
		"""Test acalcvm math_trunc with array limit  - Array code d.
		"""
		data = array.array('d', [0.0,2.4,4.8,7.2,9.6,12.0,14.4,16.8,19.2,21.6])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.trunc(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.trunc(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_operator_math_trunc_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_trunc with overflow checking disabled and array limit - Array code d.
		"""
		data = array.array('d', [0.0,2.4,4.8,7.2,9.6,12.0,14.4,16.8,19.2,21.6])
		
		dataout = array.array('d', [0]*len(data))
		
		limited = len(data) // 2

		pydataout = [math.trunc(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.trunc(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		for dataoutitem, expecteditem in zip(list(dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



##############################################################################

##############################################################################
class acalcvm_operator_bytes(unittest.TestCase):
	"""Test for basic operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'


	########################################################
	def test_operator_add_1_acalcvm(self):
		"""Test acalcvm add  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x + y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x + y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_1_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_2_acalcvm(self):
		"""Test acalcvm add  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_2_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_add_3_acalcvm(self):
		"""Test acalcvm add  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_ov(self):
		"""Test acalcvm add with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x + y for x,y in zip(list(data), itertools.repeat( 25))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_lim(self):
		"""Test acalcvm add with array limit  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_add_3_acalcvm_ov_lim(self):
		"""Test acalcvm add with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x + y for x,y in zip(list(data), itertools.repeat( 25))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_1_acalcvm(self):
		"""Test acalcvm sub  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x - y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x - y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_1_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_2_acalcvm(self):
		"""Test acalcvm sub  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_2_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_sub_3_acalcvm(self):
		"""Test acalcvm sub  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_ov(self):
		"""Test acalcvm sub with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x - y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_lim(self):
		"""Test acalcvm sub with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_sub_3_acalcvm_ov_lim(self):
		"""Test acalcvm sub with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x - y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_1_acalcvm(self):
		"""Test acalcvm mult  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x * y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x * y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_1_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_2_acalcvm(self):
		"""Test acalcvm mult  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_2_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_3_acalcvm(self):
		"""Test acalcvm mult  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_3_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mult_4_acalcvm(self):
		"""Test acalcvm mult  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_ov(self):
		"""Test acalcvm mult with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x * y for x,y in zip(list(data), itertools.repeat( 3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_lim(self):
		"""Test acalcvm mult with array limit  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mult_4_acalcvm_ov_lim(self):
		"""Test acalcvm mult with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x * y for x,y in zip(list(data), itertools.repeat( 3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_1_acalcvm(self):
		"""Test acalcvm div  - Array code bytes.
		"""
		# Template name: test_template_intdiv
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_1_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_2_acalcvm(self):
		"""Test acalcvm div  - Array code bytes.
		"""
		# Template name: test_template_intdiv
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_2_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_div_3_acalcvm(self):
		"""Test acalcvm div  - Array code bytes.
		"""
		# Template name: test_template_intdiv
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_ov(self):
		"""Test acalcvm div with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_lim(self):
		"""Test acalcvm div with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_div_3_acalcvm_ov_lim(self):
		"""Test acalcvm div with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_1_acalcvm(self):
		"""Test acalcvm floordiv  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x // y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x // y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_1_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_floordiv_2_acalcvm(self):
		"""Test acalcvm floordiv  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_ov(self):
		"""Test acalcvm floordiv with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x // y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_lim(self):
		"""Test acalcvm floordiv with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_floordiv_2_acalcvm_ov_lim(self):
		"""Test acalcvm floordiv with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x // y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_1_acalcvm(self):
		"""Test acalcvm mod  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x % y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x % y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_1_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_mod_2_acalcvm(self):
		"""Test acalcvm mod  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_ov(self):
		"""Test acalcvm mod with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x % y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_lim(self):
		"""Test acalcvm mod with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_mod_2_acalcvm_ov_lim(self):
		"""Test acalcvm mod with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x % y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_uadd_1_acalcvm(self):
		"""Test acalcvm uadd  - Array code bytes.
		"""
		# Template name: test_template_1op
		data = array.array('B', [0,1,2,3,4,5])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [+x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_ov(self):
		"""Test acalcvm uadd with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [+x for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_lim(self):
		"""Test acalcvm uadd with array limit  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [+x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_uadd_1_acalcvm_ov_lim(self):
		"""Test acalcvm uadd with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [+x for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_1_acalcvm(self):
		"""Test acalcvm pow  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x**y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x**y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_1_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_2_acalcvm(self):
		"""Test acalcvm pow  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_2_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_pow_3_acalcvm(self):
		"""Test acalcvm pow  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_ov(self):
		"""Test acalcvm pow with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x**y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_lim(self):
		"""Test acalcvm pow with array limit  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_pow_3_acalcvm_ov_lim(self):
		"""Test acalcvm pow with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x**y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_1_acalcvm(self):
		"""Test acalcvm bitand  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x & y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x & y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_2_acalcvm(self):
		"""Test acalcvm bitand  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x & y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x & y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_3_acalcvm(self):
		"""Test acalcvm bitand  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x & y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x & y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_4_acalcvm(self):
		"""Test acalcvm bitand  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x & y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x & y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_5_acalcvm(self):
		"""Test acalcvm bitand  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x & y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x & y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitand_6_acalcvm(self):
		"""Test acalcvm bitand  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x & y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_ov(self):
		"""Test acalcvm bitand with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x & y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_lim(self):
		"""Test acalcvm bitand with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitand_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitand with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x & y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x & y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_1_acalcvm(self):
		"""Test acalcvm bitor  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x | y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x | y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_2_acalcvm(self):
		"""Test acalcvm bitor  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x | y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x | y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_3_acalcvm(self):
		"""Test acalcvm bitor  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x | y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x | y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_4_acalcvm(self):
		"""Test acalcvm bitor  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x | y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x | y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_5_acalcvm(self):
		"""Test acalcvm bitor  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x | y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x | y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitor_6_acalcvm(self):
		"""Test acalcvm bitor  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x | y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_ov(self):
		"""Test acalcvm bitor with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x | y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_lim(self):
		"""Test acalcvm bitor with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitor_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitor with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x | y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x | y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_1_acalcvm(self):
		"""Test acalcvm bitxor  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_1_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_2_acalcvm(self):
		"""Test acalcvm bitxor  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_2_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_3_acalcvm(self):
		"""Test acalcvm bitxor  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_3_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_4_acalcvm(self):
		"""Test acalcvm bitxor  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_4_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(3))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([3], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_5_acalcvm(self):
		"""Test acalcvm bitxor  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_5_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(4))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([4], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_bitxor_6_acalcvm(self):
		"""Test acalcvm bitxor  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_ov(self):
		"""Test acalcvm bitxor with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_lim(self):
		"""Test acalcvm bitxor with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_bitxor_6_acalcvm_ov_lim(self):
		"""Test acalcvm bitxor with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x ^ y for x,y in zip(list(data), itertools.repeat(5))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x ^ y', 'x', ['y'])
		eqnd.execute([5], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_invert_1_acalcvm(self):
		"""Test acalcvm invert  - Array code bytes.
		"""
		# Template name: test_template_intinvert
		data = array.array('B', [1,2,3,4,5,6,7,8,9,10])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [InvertPy('B', x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_ov(self):
		"""Test acalcvm invert with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [1,2,3,4,5,6,7,8,9,10])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [InvertPy('B', x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_lim(self):
		"""Test acalcvm invert with array limit  - Array code bytes.
		"""
		data = array.array('B', [1,2,3,4,5,6,7,8,9,10])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [InvertPy('B', x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_invert_1_acalcvm_ov_lim(self):
		"""Test acalcvm invert with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [1,2,3,4,5,6,7,8,9,10])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [InvertPy('B', x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('~x', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_1_acalcvm(self):
		"""Test acalcvm lshift  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x << y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x << y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_1_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_2_acalcvm(self):
		"""Test acalcvm lshift  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_2_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_lshift_3_acalcvm(self):
		"""Test acalcvm lshift  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_ov(self):
		"""Test acalcvm lshift with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x << y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_lim(self):
		"""Test acalcvm lshift with array limit  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_lshift_3_acalcvm_ov_lim(self):
		"""Test acalcvm lshift with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5,6,7,8,9])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x << y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x << y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_1_acalcvm(self):
		"""Test acalcvm rshift  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x >> y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x >> y for x,y in zip(list(data), itertools.repeat(0))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_1_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat(0))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([0], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_2_acalcvm(self):
		"""Test acalcvm rshift  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_2_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 1))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_rshift_3_acalcvm(self):
		"""Test acalcvm rshift  - Array code bytes.
		"""
		# Template name: test_template_2ops
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_ov(self):
		"""Test acalcvm rshift with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_lim(self):
		"""Test acalcvm rshift with array limit  - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_rshift_3_acalcvm_ov_lim(self):
		"""Test acalcvm rshift with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [x >> y for x,y in zip(list(data), itertools.repeat( 2))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x >> y', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_abs_1_acalcvm(self):
		"""Test acalcvm abs  - Array code bytes.
		"""
		# Template name: test_template_1op
		data = array.array('B', [0,1,2,3,4])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [abs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_ov(self):
		"""Test acalcvm abs with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [abs(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_lim(self):
		"""Test acalcvm abs with array limit  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [abs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_abs_1_acalcvm_ov_lim(self):
		"""Test acalcvm abs with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [abs(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)



	########################################################
	def test_operator_math_factorial_1_acalcvm(self):
		"""Test acalcvm math_factorial  - Array code bytes.
		"""
		# Template name: test_template_1op
		data = array.array('B', [0,1,2,3,4,5])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [math.factorial(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=False)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_ov(self):
		"""Test acalcvm math_factorial with overflow checking disabled  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)

		expected = [math.factorial(x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_lim(self):
		"""Test acalcvm math_factorial with array limit  - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [math.factorial(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], maxlen=limited)

		self.assertEqual(list(dataout), expected)


	########################################################
	def test_operator_math_factorial_1_acalcvm_ov_lim(self):
		"""Test acalcvm math_factorial with overflow checking disabled and array limit - Array code bytes.
		"""
		data = array.array('B', [0,1,2,3,4,5])
		data = bytes(data)
		dataout = array.array('B', [0]*len(data))
		dataout = bytes(dataout)
		limited = len(data) // 2

		pydataout = [math.factorial(x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		self.assertEqual(list(dataout), expected)


##############################################################################

##############################################################################
class acalcvm_intoverflow_b(unittest.TestCase):
	"""Test for integer overflow operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'b'
		self.MaxLimit = arrayfunc.arraylimits.b_max
		self.MinLimit = arrayfunc.arraylimits.b_min



	########################################################
	def test_intoverflow_add_1_acalcvm(self):
		"""Test acalcvm integer overflow in add  - Array code b - Exceed max value.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('b', [self.MaxLimit]*10)
		
		dataout = array.array('b', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([1])



	########################################################
	def test_intoverflow_add_2_acalcvm(self):
		"""Test acalcvm integer overflow in add  - Array code b - Exceed min value.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('b', [self.MinLimit]*10)
		
		dataout = array.array('b', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_sub_1_acalcvm(self):
		"""Test acalcvm integer overflow in sub  - Array code b - greater than max.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('b', [self.MaxLimit]*10)
		
		dataout = array.array('b', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_sub_2_acalcvm(self):
		"""Test acalcvm integer overflow in sub  - Array code b - less than min.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('b', [self.MinLimit]*10)
		
		dataout = array.array('b', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([1])



	########################################################
	def test_intoverflow_mult_1_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code b - max positive.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('b', [self.MaxLimit]*10)
		
		dataout = array.array('b', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([2])



	########################################################
	def test_intoverflow_mult_2_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code b - min positive.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('b', [self.MinLimit]*10)
		
		dataout = array.array('b', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([2])



	########################################################
	def test_intoverflow_mult_3_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code b - max negative.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('b', [self.MaxLimit]*10)
		
		dataout = array.array('b', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-2])



	########################################################
	def test_intoverflow_mult_4_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code b - min negative.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('b', [self.MinLimit]*10)
		
		dataout = array.array('b', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-2])



	########################################################
	def test_intoverflow_mult_5_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code b - complement.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('b', [self.MinLimit]*10)
		
		dataout = array.array('b', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_div_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in div  - Array code b - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('b', [1]*10)
		
		dataout = array.array('b', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_div_2_acalcvm(self):
		"""Test acalcvm integer overflow in div  - Array code b - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('b', [1]*10)
		
		dataout = array.array('b', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_div_3_acalcvm(self):
		"""Test acalcvm integer overflow in div  - Array code b - Negate.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('b', [self.MinLimit]*10)
		
		dataout = array.array('b', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_floordiv_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in floordiv  - Array code b - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('b', [1]*10)
		
		dataout = array.array('b', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_floordiv_2_acalcvm(self):
		"""Test acalcvm integer overflow in floordiv  - Array code b - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('b', [1]*10)
		
		dataout = array.array('b', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_floordiv_3_acalcvm(self):
		"""Test acalcvm integer overflow in floordiv  - Array code b - Negate.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('b', [self.MinLimit]*10)
		
		dataout = array.array('b', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_mod_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in mod  - Array code b - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('b', [1]*10)
		
		dataout = array.array('b', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_mod_2_acalcvm(self):
		"""Test acalcvm integer overflow in mod  - Array code b - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('b', [1]*10)
		
		dataout = array.array('b', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_usub_1_acalcvm(self):
		"""Test acalcvm integer overflow in usub  - Array code b - greater than max.
		"""
		# Template name: intoverflow_template_1ops
		data = array.array('b', [self.MinLimit]*10)
		
		dataout = array.array('b', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])



	########################################################
	def test_intoverflow_pow_1_acalcvm(self):
		"""Test acalcvm integer overflow in pow  - Array code b - raised to negative power.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('b', [0]*10)
		
		dataout = array.array('b', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_abs_1_acalcvm(self):
		"""Test acalcvm integer overflow in abs  - Array code b - negate min signed.
		"""
		# Template name: intoverflow_template_1ops
		data = array.array('b', [self.MinLimit]*10)
		
		dataout = array.array('b', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])



	########################################################
	def test_intoverflow_math_factorial_1_acalcvm(self):
		"""Test acalcvm integer overflow in math.factorial  - Array code b - greater than max.
		"""
		# Template name: intoverflow_template_1ops
		data = array.array('b', [self.MaxLimit]*10)
		
		dataout = array.array('b', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])



	########################################################
	def test_intoverflow_math_factorial_2_acalcvm(self):
		"""Test acalcvm integer overflow in math.factorial  - Array code b - negative factorial.
		"""
		# Template name: intoverflow_template_1ops
		data = array.array('b', [-1]*10)
		
		dataout = array.array('b', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


##############################################################################

##############################################################################
class acalcvm_intoverflow_B(unittest.TestCase):
	"""Test for integer overflow operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'
		self.MaxLimit = arrayfunc.arraylimits.B_max
		self.MinLimit = arrayfunc.arraylimits.B_min



	########################################################
	def test_intoverflow_add_1_acalcvm(self):
		"""Test acalcvm integer overflow in add  - Array code B - Exceed max value.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('B', [self.MaxLimit]*10)
		
		dataout = array.array('B', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([1])



	########################################################
	def test_intoverflow_sub_1_acalcvm(self):
		"""Test acalcvm integer overflow in sub  - Array code B - less than min.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('B', [self.MinLimit]*10)
		
		dataout = array.array('B', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([1])



	########################################################
	def test_intoverflow_mult_1_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code B - max positive.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('B', [self.MaxLimit]*10)
		
		dataout = array.array('B', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([2])



	########################################################
	def test_intoverflow_div_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in div  - Array code B - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('B', [1]*10)
		
		dataout = array.array('B', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_div_2_acalcvm(self):
		"""Test acalcvm integer overflow in div  - Array code B - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('B', [1]*10)
		
		dataout = array.array('B', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_floordiv_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in floordiv  - Array code B - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('B', [1]*10)
		
		dataout = array.array('B', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_floordiv_2_acalcvm(self):
		"""Test acalcvm integer overflow in floordiv  - Array code B - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('B', [1]*10)
		
		dataout = array.array('B', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_mod_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in mod  - Array code B - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('B', [1]*10)
		
		dataout = array.array('B', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_mod_2_acalcvm(self):
		"""Test acalcvm integer overflow in mod  - Array code B - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('B', [1]*10)
		
		dataout = array.array('B', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_math_factorial_1_acalcvm(self):
		"""Test acalcvm integer overflow in math.factorial  - Array code B - greater than max.
		"""
		# Template name: intoverflow_template_1ops
		data = array.array('B', [self.MaxLimit]*10)
		
		dataout = array.array('B', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


##############################################################################

##############################################################################
class acalcvm_intoverflow_h(unittest.TestCase):
	"""Test for integer overflow operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'h'
		self.MaxLimit = arrayfunc.arraylimits.h_max
		self.MinLimit = arrayfunc.arraylimits.h_min



	########################################################
	def test_intoverflow_add_1_acalcvm(self):
		"""Test acalcvm integer overflow in add  - Array code h - Exceed max value.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('h', [self.MaxLimit]*10)
		
		dataout = array.array('h', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([1])



	########################################################
	def test_intoverflow_add_2_acalcvm(self):
		"""Test acalcvm integer overflow in add  - Array code h - Exceed min value.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('h', [self.MinLimit]*10)
		
		dataout = array.array('h', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_sub_1_acalcvm(self):
		"""Test acalcvm integer overflow in sub  - Array code h - greater than max.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('h', [self.MaxLimit]*10)
		
		dataout = array.array('h', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_sub_2_acalcvm(self):
		"""Test acalcvm integer overflow in sub  - Array code h - less than min.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('h', [self.MinLimit]*10)
		
		dataout = array.array('h', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([1])



	########################################################
	def test_intoverflow_mult_1_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code h - max positive.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('h', [self.MaxLimit]*10)
		
		dataout = array.array('h', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([2])



	########################################################
	def test_intoverflow_mult_2_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code h - min positive.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('h', [self.MinLimit]*10)
		
		dataout = array.array('h', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([2])



	########################################################
	def test_intoverflow_mult_3_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code h - max negative.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('h', [self.MaxLimit]*10)
		
		dataout = array.array('h', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-2])



	########################################################
	def test_intoverflow_mult_4_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code h - min negative.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('h', [self.MinLimit]*10)
		
		dataout = array.array('h', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-2])



	########################################################
	def test_intoverflow_mult_5_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code h - complement.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('h', [self.MinLimit]*10)
		
		dataout = array.array('h', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_div_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in div  - Array code h - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('h', [1]*10)
		
		dataout = array.array('h', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_div_2_acalcvm(self):
		"""Test acalcvm integer overflow in div  - Array code h - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('h', [1]*10)
		
		dataout = array.array('h', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_div_3_acalcvm(self):
		"""Test acalcvm integer overflow in div  - Array code h - Negate.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('h', [self.MinLimit]*10)
		
		dataout = array.array('h', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_floordiv_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in floordiv  - Array code h - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('h', [1]*10)
		
		dataout = array.array('h', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_floordiv_2_acalcvm(self):
		"""Test acalcvm integer overflow in floordiv  - Array code h - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('h', [1]*10)
		
		dataout = array.array('h', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_floordiv_3_acalcvm(self):
		"""Test acalcvm integer overflow in floordiv  - Array code h - Negate.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('h', [self.MinLimit]*10)
		
		dataout = array.array('h', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_mod_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in mod  - Array code h - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('h', [1]*10)
		
		dataout = array.array('h', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_mod_2_acalcvm(self):
		"""Test acalcvm integer overflow in mod  - Array code h - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('h', [1]*10)
		
		dataout = array.array('h', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_usub_1_acalcvm(self):
		"""Test acalcvm integer overflow in usub  - Array code h - greater than max.
		"""
		# Template name: intoverflow_template_1ops
		data = array.array('h', [self.MinLimit]*10)
		
		dataout = array.array('h', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])



	########################################################
	def test_intoverflow_pow_1_acalcvm(self):
		"""Test acalcvm integer overflow in pow  - Array code h - raised to negative power.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('h', [0]*10)
		
		dataout = array.array('h', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_abs_1_acalcvm(self):
		"""Test acalcvm integer overflow in abs  - Array code h - negate min signed.
		"""
		# Template name: intoverflow_template_1ops
		data = array.array('h', [self.MinLimit]*10)
		
		dataout = array.array('h', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])



	########################################################
	def test_intoverflow_math_factorial_1_acalcvm(self):
		"""Test acalcvm integer overflow in math.factorial  - Array code h - greater than max.
		"""
		# Template name: intoverflow_template_1ops
		data = array.array('h', [self.MaxLimit]*10)
		
		dataout = array.array('h', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])



	########################################################
	def test_intoverflow_math_factorial_2_acalcvm(self):
		"""Test acalcvm integer overflow in math.factorial  - Array code h - negative factorial.
		"""
		# Template name: intoverflow_template_1ops
		data = array.array('h', [-1]*10)
		
		dataout = array.array('h', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


##############################################################################

##############################################################################
class acalcvm_intoverflow_H(unittest.TestCase):
	"""Test for integer overflow operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'H'
		self.MaxLimit = arrayfunc.arraylimits.H_max
		self.MinLimit = arrayfunc.arraylimits.H_min



	########################################################
	def test_intoverflow_add_1_acalcvm(self):
		"""Test acalcvm integer overflow in add  - Array code H - Exceed max value.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('H', [self.MaxLimit]*10)
		
		dataout = array.array('H', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([1])



	########################################################
	def test_intoverflow_sub_1_acalcvm(self):
		"""Test acalcvm integer overflow in sub  - Array code H - less than min.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('H', [self.MinLimit]*10)
		
		dataout = array.array('H', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([1])



	########################################################
	def test_intoverflow_mult_1_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code H - max positive.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('H', [self.MaxLimit]*10)
		
		dataout = array.array('H', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([2])



	########################################################
	def test_intoverflow_div_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in div  - Array code H - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('H', [1]*10)
		
		dataout = array.array('H', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_div_2_acalcvm(self):
		"""Test acalcvm integer overflow in div  - Array code H - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('H', [1]*10)
		
		dataout = array.array('H', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_floordiv_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in floordiv  - Array code H - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('H', [1]*10)
		
		dataout = array.array('H', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_floordiv_2_acalcvm(self):
		"""Test acalcvm integer overflow in floordiv  - Array code H - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('H', [1]*10)
		
		dataout = array.array('H', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_mod_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in mod  - Array code H - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('H', [1]*10)
		
		dataout = array.array('H', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_mod_2_acalcvm(self):
		"""Test acalcvm integer overflow in mod  - Array code H - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('H', [1]*10)
		
		dataout = array.array('H', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_math_factorial_1_acalcvm(self):
		"""Test acalcvm integer overflow in math.factorial  - Array code H - greater than max.
		"""
		# Template name: intoverflow_template_1ops
		data = array.array('H', [self.MaxLimit]*10)
		
		dataout = array.array('H', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


##############################################################################

##############################################################################
class acalcvm_intoverflow_i(unittest.TestCase):
	"""Test for integer overflow operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'i'
		self.MaxLimit = arrayfunc.arraylimits.i_max
		self.MinLimit = arrayfunc.arraylimits.i_min



	########################################################
	def test_intoverflow_add_1_acalcvm(self):
		"""Test acalcvm integer overflow in add  - Array code i - Exceed max value.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('i', [self.MaxLimit]*10)
		
		dataout = array.array('i', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([1])



	########################################################
	def test_intoverflow_add_2_acalcvm(self):
		"""Test acalcvm integer overflow in add  - Array code i - Exceed min value.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('i', [self.MinLimit]*10)
		
		dataout = array.array('i', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_sub_1_acalcvm(self):
		"""Test acalcvm integer overflow in sub  - Array code i - greater than max.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('i', [self.MaxLimit]*10)
		
		dataout = array.array('i', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_sub_2_acalcvm(self):
		"""Test acalcvm integer overflow in sub  - Array code i - less than min.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('i', [self.MinLimit]*10)
		
		dataout = array.array('i', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([1])



	########################################################
	def test_intoverflow_mult_1_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code i - max positive.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('i', [self.MaxLimit]*10)
		
		dataout = array.array('i', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([2])



	########################################################
	def test_intoverflow_mult_2_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code i - min positive.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('i', [self.MinLimit]*10)
		
		dataout = array.array('i', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([2])



	########################################################
	def test_intoverflow_mult_3_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code i - max negative.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('i', [self.MaxLimit]*10)
		
		dataout = array.array('i', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-2])



	########################################################
	def test_intoverflow_mult_4_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code i - min negative.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('i', [self.MinLimit]*10)
		
		dataout = array.array('i', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-2])



	########################################################
	def test_intoverflow_mult_5_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code i - complement.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('i', [self.MinLimit]*10)
		
		dataout = array.array('i', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_div_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in div  - Array code i - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('i', [1]*10)
		
		dataout = array.array('i', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_div_2_acalcvm(self):
		"""Test acalcvm integer overflow in div  - Array code i - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('i', [1]*10)
		
		dataout = array.array('i', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_div_3_acalcvm(self):
		"""Test acalcvm integer overflow in div  - Array code i - Negate.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('i', [self.MinLimit]*10)
		
		dataout = array.array('i', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_floordiv_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in floordiv  - Array code i - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('i', [1]*10)
		
		dataout = array.array('i', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_floordiv_2_acalcvm(self):
		"""Test acalcvm integer overflow in floordiv  - Array code i - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('i', [1]*10)
		
		dataout = array.array('i', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_floordiv_3_acalcvm(self):
		"""Test acalcvm integer overflow in floordiv  - Array code i - Negate.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('i', [self.MinLimit]*10)
		
		dataout = array.array('i', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_mod_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in mod  - Array code i - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('i', [1]*10)
		
		dataout = array.array('i', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_mod_2_acalcvm(self):
		"""Test acalcvm integer overflow in mod  - Array code i - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('i', [1]*10)
		
		dataout = array.array('i', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_usub_1_acalcvm(self):
		"""Test acalcvm integer overflow in usub  - Array code i - greater than max.
		"""
		# Template name: intoverflow_template_1ops
		data = array.array('i', [self.MinLimit]*10)
		
		dataout = array.array('i', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])



	########################################################
	def test_intoverflow_pow_1_acalcvm(self):
		"""Test acalcvm integer overflow in pow  - Array code i - raised to negative power.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('i', [0]*10)
		
		dataout = array.array('i', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_abs_1_acalcvm(self):
		"""Test acalcvm integer overflow in abs  - Array code i - negate min signed.
		"""
		# Template name: intoverflow_template_1ops
		data = array.array('i', [self.MinLimit]*10)
		
		dataout = array.array('i', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])



	########################################################
	def test_intoverflow_math_factorial_1_acalcvm(self):
		"""Test acalcvm integer overflow in math.factorial  - Array code i - greater than max.
		"""
		# Template name: intoverflow_template_1ops
		data = array.array('i', [self.MaxLimit]*10)
		
		dataout = array.array('i', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])



	########################################################
	def test_intoverflow_math_factorial_2_acalcvm(self):
		"""Test acalcvm integer overflow in math.factorial  - Array code i - negative factorial.
		"""
		# Template name: intoverflow_template_1ops
		data = array.array('i', [-1]*10)
		
		dataout = array.array('i', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


##############################################################################

##############################################################################
class acalcvm_intoverflow_I(unittest.TestCase):
	"""Test for integer overflow operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'I'
		self.MaxLimit = arrayfunc.arraylimits.I_max
		self.MinLimit = arrayfunc.arraylimits.I_min



	########################################################
	def test_intoverflow_add_1_acalcvm(self):
		"""Test acalcvm integer overflow in add  - Array code I - Exceed max value.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('I', [self.MaxLimit]*10)
		
		dataout = array.array('I', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([1])



	########################################################
	def test_intoverflow_sub_1_acalcvm(self):
		"""Test acalcvm integer overflow in sub  - Array code I - less than min.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('I', [self.MinLimit]*10)
		
		dataout = array.array('I', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([1])



	########################################################
	def test_intoverflow_mult_1_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code I - max positive.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('I', [self.MaxLimit]*10)
		
		dataout = array.array('I', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([2])



	########################################################
	def test_intoverflow_div_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in div  - Array code I - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('I', [1]*10)
		
		dataout = array.array('I', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_div_2_acalcvm(self):
		"""Test acalcvm integer overflow in div  - Array code I - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('I', [1]*10)
		
		dataout = array.array('I', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_floordiv_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in floordiv  - Array code I - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('I', [1]*10)
		
		dataout = array.array('I', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_floordiv_2_acalcvm(self):
		"""Test acalcvm integer overflow in floordiv  - Array code I - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('I', [1]*10)
		
		dataout = array.array('I', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_mod_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in mod  - Array code I - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('I', [1]*10)
		
		dataout = array.array('I', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_mod_2_acalcvm(self):
		"""Test acalcvm integer overflow in mod  - Array code I - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('I', [1]*10)
		
		dataout = array.array('I', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_math_factorial_1_acalcvm(self):
		"""Test acalcvm integer overflow in math.factorial  - Array code I - greater than max.
		"""
		# Template name: intoverflow_template_1ops
		data = array.array('I', [self.MaxLimit]*10)
		
		dataout = array.array('I', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


##############################################################################

##############################################################################
class acalcvm_intoverflow_l(unittest.TestCase):
	"""Test for integer overflow operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'l'
		self.MaxLimit = arrayfunc.arraylimits.l_max
		self.MinLimit = arrayfunc.arraylimits.l_min



	########################################################
	def test_intoverflow_add_1_acalcvm(self):
		"""Test acalcvm integer overflow in add  - Array code l - Exceed max value.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('l', [self.MaxLimit]*10)
		
		dataout = array.array('l', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([1])



	########################################################
	def test_intoverflow_add_2_acalcvm(self):
		"""Test acalcvm integer overflow in add  - Array code l - Exceed min value.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('l', [self.MinLimit]*10)
		
		dataout = array.array('l', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_sub_1_acalcvm(self):
		"""Test acalcvm integer overflow in sub  - Array code l - greater than max.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('l', [self.MaxLimit]*10)
		
		dataout = array.array('l', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_sub_2_acalcvm(self):
		"""Test acalcvm integer overflow in sub  - Array code l - less than min.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('l', [self.MinLimit]*10)
		
		dataout = array.array('l', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([1])



	########################################################
	def test_intoverflow_mult_1_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code l - max positive.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('l', [self.MaxLimit]*10)
		
		dataout = array.array('l', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([2])



	########################################################
	def test_intoverflow_mult_2_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code l - min positive.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('l', [self.MinLimit]*10)
		
		dataout = array.array('l', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([2])



	########################################################
	def test_intoverflow_mult_3_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code l - max negative.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('l', [self.MaxLimit]*10)
		
		dataout = array.array('l', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-2])



	########################################################
	def test_intoverflow_mult_4_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code l - min negative.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('l', [self.MinLimit]*10)
		
		dataout = array.array('l', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-2])



	########################################################
	def test_intoverflow_mult_5_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code l - complement.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('l', [self.MinLimit]*10)
		
		dataout = array.array('l', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_div_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in div  - Array code l - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('l', [1]*10)
		
		dataout = array.array('l', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_div_2_acalcvm(self):
		"""Test acalcvm integer overflow in div  - Array code l - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('l', [1]*10)
		
		dataout = array.array('l', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_div_3_acalcvm(self):
		"""Test acalcvm integer overflow in div  - Array code l - Negate.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('l', [self.MinLimit]*10)
		
		dataout = array.array('l', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_floordiv_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in floordiv  - Array code l - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('l', [1]*10)
		
		dataout = array.array('l', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_floordiv_2_acalcvm(self):
		"""Test acalcvm integer overflow in floordiv  - Array code l - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('l', [1]*10)
		
		dataout = array.array('l', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_floordiv_3_acalcvm(self):
		"""Test acalcvm integer overflow in floordiv  - Array code l - Negate.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('l', [self.MinLimit]*10)
		
		dataout = array.array('l', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_mod_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in mod  - Array code l - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('l', [1]*10)
		
		dataout = array.array('l', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_mod_2_acalcvm(self):
		"""Test acalcvm integer overflow in mod  - Array code l - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('l', [1]*10)
		
		dataout = array.array('l', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_usub_1_acalcvm(self):
		"""Test acalcvm integer overflow in usub  - Array code l - greater than max.
		"""
		# Template name: intoverflow_template_1ops
		data = array.array('l', [self.MinLimit]*10)
		
		dataout = array.array('l', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])



	########################################################
	def test_intoverflow_pow_1_acalcvm(self):
		"""Test acalcvm integer overflow in pow  - Array code l - raised to negative power.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('l', [0]*10)
		
		dataout = array.array('l', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_abs_1_acalcvm(self):
		"""Test acalcvm integer overflow in abs  - Array code l - negate min signed.
		"""
		# Template name: intoverflow_template_1ops
		data = array.array('l', [self.MinLimit]*10)
		
		dataout = array.array('l', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])



	########################################################
	def test_intoverflow_math_factorial_1_acalcvm(self):
		"""Test acalcvm integer overflow in math.factorial  - Array code l - greater than max.
		"""
		# Template name: intoverflow_template_1ops
		data = array.array('l', [self.MaxLimit]*10)
		
		dataout = array.array('l', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])



	########################################################
	def test_intoverflow_math_factorial_2_acalcvm(self):
		"""Test acalcvm integer overflow in math.factorial  - Array code l - negative factorial.
		"""
		# Template name: intoverflow_template_1ops
		data = array.array('l', [-1]*10)
		
		dataout = array.array('l', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


##############################################################################

##############################################################################
class acalcvm_intoverflow_L(unittest.TestCase):
	"""Test for integer overflow operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'L'
		self.MaxLimit = arrayfunc.arraylimits.L_max
		self.MinLimit = arrayfunc.arraylimits.L_min



	########################################################
	def test_intoverflow_add_1_acalcvm(self):
		"""Test acalcvm integer overflow in add  - Array code L - Exceed max value.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('L', [self.MaxLimit]*10)
		
		dataout = array.array('L', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([1])



	########################################################
	def test_intoverflow_sub_1_acalcvm(self):
		"""Test acalcvm integer overflow in sub  - Array code L - less than min.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('L', [self.MinLimit]*10)
		
		dataout = array.array('L', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([1])



	########################################################
	def test_intoverflow_mult_1_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code L - max positive.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('L', [self.MaxLimit]*10)
		
		dataout = array.array('L', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([2])



	########################################################
	def test_intoverflow_div_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in div  - Array code L - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('L', [1]*10)
		
		dataout = array.array('L', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_div_2_acalcvm(self):
		"""Test acalcvm integer overflow in div  - Array code L - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('L', [1]*10)
		
		dataout = array.array('L', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_floordiv_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in floordiv  - Array code L - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('L', [1]*10)
		
		dataout = array.array('L', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_floordiv_2_acalcvm(self):
		"""Test acalcvm integer overflow in floordiv  - Array code L - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('L', [1]*10)
		
		dataout = array.array('L', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_mod_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in mod  - Array code L - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('L', [1]*10)
		
		dataout = array.array('L', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_mod_2_acalcvm(self):
		"""Test acalcvm integer overflow in mod  - Array code L - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('L', [1]*10)
		
		dataout = array.array('L', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_math_factorial_1_acalcvm(self):
		"""Test acalcvm integer overflow in math.factorial  - Array code L - greater than max.
		"""
		# Template name: intoverflow_template_1ops
		data = array.array('L', [self.MaxLimit]*10)
		
		dataout = array.array('L', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


##############################################################################

##############################################################################
class acalcvm_intoverflow_q(unittest.TestCase):
	"""Test for integer overflow operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'q'
		self.MaxLimit = arrayfunc.arraylimits.q_max
		self.MinLimit = arrayfunc.arraylimits.q_min



	########################################################
	def test_intoverflow_add_1_acalcvm(self):
		"""Test acalcvm integer overflow in add  - Array code q - Exceed max value.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('q', [self.MaxLimit]*10)
		
		dataout = array.array('q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([1])



	########################################################
	def test_intoverflow_add_2_acalcvm(self):
		"""Test acalcvm integer overflow in add  - Array code q - Exceed min value.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('q', [self.MinLimit]*10)
		
		dataout = array.array('q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_sub_1_acalcvm(self):
		"""Test acalcvm integer overflow in sub  - Array code q - greater than max.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('q', [self.MaxLimit]*10)
		
		dataout = array.array('q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_sub_2_acalcvm(self):
		"""Test acalcvm integer overflow in sub  - Array code q - less than min.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('q', [self.MinLimit]*10)
		
		dataout = array.array('q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([1])



	########################################################
	def test_intoverflow_mult_1_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code q - max positive.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('q', [self.MaxLimit]*10)
		
		dataout = array.array('q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([2])



	########################################################
	def test_intoverflow_mult_2_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code q - min positive.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('q', [self.MinLimit]*10)
		
		dataout = array.array('q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([2])



	########################################################
	def test_intoverflow_mult_3_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code q - max negative.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('q', [self.MaxLimit]*10)
		
		dataout = array.array('q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-2])



	########################################################
	def test_intoverflow_mult_4_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code q - min negative.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('q', [self.MinLimit]*10)
		
		dataout = array.array('q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-2])



	########################################################
	def test_intoverflow_mult_5_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code q - complement.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('q', [self.MinLimit]*10)
		
		dataout = array.array('q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_div_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in div  - Array code q - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('q', [1]*10)
		
		dataout = array.array('q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_div_2_acalcvm(self):
		"""Test acalcvm integer overflow in div  - Array code q - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('q', [1]*10)
		
		dataout = array.array('q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_div_3_acalcvm(self):
		"""Test acalcvm integer overflow in div  - Array code q - Negate.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('q', [self.MinLimit]*10)
		
		dataout = array.array('q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_floordiv_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in floordiv  - Array code q - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('q', [1]*10)
		
		dataout = array.array('q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_floordiv_2_acalcvm(self):
		"""Test acalcvm integer overflow in floordiv  - Array code q - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('q', [1]*10)
		
		dataout = array.array('q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_floordiv_3_acalcvm(self):
		"""Test acalcvm integer overflow in floordiv  - Array code q - Negate.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('q', [self.MinLimit]*10)
		
		dataout = array.array('q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_mod_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in mod  - Array code q - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('q', [1]*10)
		
		dataout = array.array('q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_mod_2_acalcvm(self):
		"""Test acalcvm integer overflow in mod  - Array code q - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('q', [1]*10)
		
		dataout = array.array('q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_usub_1_acalcvm(self):
		"""Test acalcvm integer overflow in usub  - Array code q - greater than max.
		"""
		# Template name: intoverflow_template_1ops
		data = array.array('q', [self.MinLimit]*10)
		
		dataout = array.array('q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('-x', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])



	########################################################
	def test_intoverflow_pow_1_acalcvm(self):
		"""Test acalcvm integer overflow in pow  - Array code q - raised to negative power.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('q', [0]*10)
		
		dataout = array.array('q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1])



	########################################################
	def test_intoverflow_abs_1_acalcvm(self):
		"""Test acalcvm integer overflow in abs  - Array code q - negate min signed.
		"""
		# Template name: intoverflow_template_1ops
		data = array.array('q', [self.MinLimit]*10)
		
		dataout = array.array('q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('abs(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])



	########################################################
	def test_intoverflow_math_factorial_1_acalcvm(self):
		"""Test acalcvm integer overflow in math.factorial  - Array code q - greater than max.
		"""
		# Template name: intoverflow_template_1ops
		data = array.array('q', [self.MaxLimit]*10)
		
		dataout = array.array('q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])



	########################################################
	def test_intoverflow_math_factorial_2_acalcvm(self):
		"""Test acalcvm integer overflow in math.factorial  - Array code q - negative factorial.
		"""
		# Template name: intoverflow_template_1ops
		data = array.array('q', [-1]*10)
		
		dataout = array.array('q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


##############################################################################

##############################################################################
class acalcvm_intoverflow_Q(unittest.TestCase):
	"""Test for integer overflow operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'Q'
		self.MaxLimit = arrayfunc.arraylimits.Q_max
		self.MinLimit = arrayfunc.arraylimits.Q_min



	########################################################
	def test_intoverflow_add_1_acalcvm(self):
		"""Test acalcvm integer overflow in add  - Array code Q - Exceed max value.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('Q', [self.MaxLimit]*10)
		
		dataout = array.array('Q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([1])



	########################################################
	def test_intoverflow_sub_1_acalcvm(self):
		"""Test acalcvm integer overflow in sub  - Array code Q - less than min.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('Q', [self.MinLimit]*10)
		
		dataout = array.array('Q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([1])



	########################################################
	def test_intoverflow_mult_1_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code Q - max positive.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('Q', [self.MaxLimit]*10)
		
		dataout = array.array('Q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([2])



	########################################################
	def test_intoverflow_div_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in div  - Array code Q - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('Q', [1]*10)
		
		dataout = array.array('Q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_div_2_acalcvm(self):
		"""Test acalcvm integer overflow in div  - Array code Q - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('Q', [1]*10)
		
		dataout = array.array('Q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_floordiv_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in floordiv  - Array code Q - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('Q', [1]*10)
		
		dataout = array.array('Q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_floordiv_2_acalcvm(self):
		"""Test acalcvm integer overflow in floordiv  - Array code Q - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('Q', [1]*10)
		
		dataout = array.array('Q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_mod_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in mod  - Array code Q - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('Q', [1]*10)
		
		dataout = array.array('Q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_mod_2_acalcvm(self):
		"""Test acalcvm integer overflow in mod  - Array code Q - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('Q', [1]*10)
		
		dataout = array.array('Q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_math_factorial_1_acalcvm(self):
		"""Test acalcvm integer overflow in math.factorial  - Array code Q - greater than max.
		"""
		# Template name: intoverflow_template_1ops
		data = array.array('Q', [self.MaxLimit]*10)
		
		dataout = array.array('Q', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


##############################################################################

##############################################################################
class acalcvm_intoverflow_f(unittest.TestCase):
	"""Test for integer overflow operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'f'
		self.MaxLimit = arrayfunc.arraylimits.f_max
		self.MinLimit = arrayfunc.arraylimits.f_min



	########################################################
	def test_floatoverflow_add_1_acalcvm(self):
		"""Test acalcvm floating point overflow in add  - Array code f - max overflow.
		"""
		# Template name: floatoverflow_template_2ops
		data = array.array('f', [self.MaxLimit]*10)
		
		dataout = array.array('f', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([self.MaxLimit/10.0])


	########################################################
	def test_floatoverflow_add_2_acalcvm(self):
		"""Test acalcvm floating point overflow in add  - Array code f - min overflow.
		"""
		# Template name: floatoverflow_template_2ops
		data = array.array('f', [self.MinLimit]*10)
		
		dataout = array.array('f', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([self.MinLimit/10.0])


	########################################################
	def test_floatoverflow_sub_1_acalcvm(self):
		"""Test acalcvm floating point overflow in sub  - Array code f - greater than max.
		"""
		# Template name: floatoverflow_template_2ops
		data = array.array('f', [self.MaxLimit]*10)
		
		dataout = array.array('f', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([self.MinLimit/10.0])


	########################################################
	def test_floatoverflow_sub_2_acalcvm(self):
		"""Test acalcvm floating point overflow in sub  - Array code f - less than min.
		"""
		# Template name: floatoverflow_template_2ops
		data = array.array('f', [self.MinLimit]*10)
		
		dataout = array.array('f', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([self.MaxLimit/10.0])


	########################################################
	def test_floatoverflow_mult_1_acalcvm(self):
		"""Test acalcvm floating point overflow in mult  - Array code f - max overflow.
		"""
		# Template name: floatoverflow_template_2ops
		data = array.array('f', [self.MaxLimit]*10)
		
		dataout = array.array('f', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([2.0])


	########################################################
	def test_floatoverflow_div_1_acalcvm(self):
		"""Test acalcvm floating point overflow in div  - Array code f - divide by zero.
		"""
		# Template name: floatoverflow_template_2ops
		data = array.array('f', [1.0]*10)
		
		dataout = array.array('f', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0.0])


	########################################################
	def test_floatoverflow_floordiv_1_acalcvm(self):
		"""Test acalcvm floating point overflow in floordiv  - Array code f - divide by zero.
		"""
		# Template name: floatoverflow_template_2ops
		data = array.array('f', [1.0]*10)
		
		dataout = array.array('f', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0.0])


	########################################################
	def test_floatoverflow_mod_1_acalcvm(self):
		"""Test acalcvm floating point overflow in mod  - Array code f - divide by zero.
		"""
		# Template name: floatoverflow_template_2ops
		data = array.array('f', [1.0]*10)
		
		dataout = array.array('f', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0.0])


	########################################################
	def test_floatoverflow_pow_1_acalcvm(self):
		"""Test acalcvm floating point overflow in pow  - Array code f - 0 raised to negative power.
		"""
		# Template name: floatoverflow_template_2ops
		data = array.array('f', [0.0]*10)
		
		dataout = array.array('f', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1.0])

##############################################################################

##############################################################################
class acalcvm_intoverflow_d(unittest.TestCase):
	"""Test for integer overflow operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'd'
		self.MaxLimit = arrayfunc.arraylimits.d_max
		self.MinLimit = arrayfunc.arraylimits.d_min



	########################################################
	def test_floatoverflow_add_1_acalcvm(self):
		"""Test acalcvm floating point overflow in add  - Array code d - max overflow.
		"""
		# Template name: floatoverflow_template_2ops
		data = array.array('d', [self.MaxLimit]*10)
		
		dataout = array.array('d', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([self.MaxLimit/10.0])


	########################################################
	def test_floatoverflow_add_2_acalcvm(self):
		"""Test acalcvm floating point overflow in add  - Array code d - min overflow.
		"""
		# Template name: floatoverflow_template_2ops
		data = array.array('d', [self.MinLimit]*10)
		
		dataout = array.array('d', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([self.MinLimit/10.0])


	########################################################
	def test_floatoverflow_sub_1_acalcvm(self):
		"""Test acalcvm floating point overflow in sub  - Array code d - greater than max.
		"""
		# Template name: floatoverflow_template_2ops
		data = array.array('d', [self.MaxLimit]*10)
		
		dataout = array.array('d', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([self.MinLimit/10.0])


	########################################################
	def test_floatoverflow_sub_2_acalcvm(self):
		"""Test acalcvm floating point overflow in sub  - Array code d - less than min.
		"""
		# Template name: floatoverflow_template_2ops
		data = array.array('d', [self.MinLimit]*10)
		
		dataout = array.array('d', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([self.MaxLimit/10.0])


	########################################################
	def test_floatoverflow_mult_1_acalcvm(self):
		"""Test acalcvm floating point overflow in mult  - Array code d - max overflow.
		"""
		# Template name: floatoverflow_template_2ops
		data = array.array('d', [self.MaxLimit]*10)
		
		dataout = array.array('d', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([2.0])


	########################################################
	def test_floatoverflow_div_1_acalcvm(self):
		"""Test acalcvm floating point overflow in div  - Array code d - divide by zero.
		"""
		# Template name: floatoverflow_template_2ops
		data = array.array('d', [1.0]*10)
		
		dataout = array.array('d', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0.0])


	########################################################
	def test_floatoverflow_floordiv_1_acalcvm(self):
		"""Test acalcvm floating point overflow in floordiv  - Array code d - divide by zero.
		"""
		# Template name: floatoverflow_template_2ops
		data = array.array('d', [1.0]*10)
		
		dataout = array.array('d', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0.0])


	########################################################
	def test_floatoverflow_mod_1_acalcvm(self):
		"""Test acalcvm floating point overflow in mod  - Array code d - divide by zero.
		"""
		# Template name: floatoverflow_template_2ops
		data = array.array('d', [1.0]*10)
		
		dataout = array.array('d', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0.0])


	########################################################
	def test_floatoverflow_pow_1_acalcvm(self):
		"""Test acalcvm floating point overflow in pow  - Array code d - 0 raised to negative power.
		"""
		# Template name: floatoverflow_template_2ops
		data = array.array('d', [0.0]*10)
		
		dataout = array.array('d', [0]*10)
		

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x**y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-1.0])

##############################################################################

##############################################################################
class acalcvm_intoverflow_bytes(unittest.TestCase):
	"""Test for integer overflow operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'
		self.MaxLimit = arrayfunc.arraylimits.B_max
		self.MinLimit = arrayfunc.arraylimits.B_min



	########################################################
	def test_intoverflow_add_1_acalcvm(self):
		"""Test acalcvm integer overflow in add  - Array code bytes - Exceed max value.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('B', [self.MaxLimit]*10)
		data = bytes(data)
		dataout = array.array('B', [0]*10)
		dataout = bytes(dataout)

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x + y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([1])



	########################################################
	def test_intoverflow_sub_1_acalcvm(self):
		"""Test acalcvm integer overflow in sub  - Array code bytes - less than min.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('B', [self.MinLimit]*10)
		data = bytes(data)
		dataout = array.array('B', [0]*10)
		dataout = bytes(dataout)

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x - y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([1])



	########################################################
	def test_intoverflow_mult_1_acalcvm(self):
		"""Test acalcvm integer overflow in mult  - Array code bytes - max positive.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('B', [self.MaxLimit]*10)
		data = bytes(data)
		dataout = array.array('B', [0]*10)
		dataout = bytes(dataout)

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x * y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([2])



	########################################################
	def test_intoverflow_div_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in div  - Array code bytes - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('B', [1]*10)
		data = bytes(data)
		dataout = array.array('B', [0]*10)
		dataout = bytes(dataout)

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_div_2_acalcvm(self):
		"""Test acalcvm integer overflow in div  - Array code bytes - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('B', [1]*10)
		data = bytes(data)
		dataout = array.array('B', [0]*10)
		dataout = bytes(dataout)

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x / y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_floordiv_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in floordiv  - Array code bytes - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('B', [1]*10)
		data = bytes(data)
		dataout = array.array('B', [0]*10)
		dataout = bytes(dataout)

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_floordiv_2_acalcvm(self):
		"""Test acalcvm integer overflow in floordiv  - Array code bytes - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('B', [1]*10)
		data = bytes(data)
		dataout = array.array('B', [0]*10)
		dataout = bytes(dataout)

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x // y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_mod_1_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in mod  - Array code bytes - Div by zero.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('B', [1]*10)
		data = bytes(data)
		dataout = array.array('B', [0]*10)
		dataout = bytes(dataout)

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0], disovfl=True)



	########################################################
	def test_intoverflow_mod_2_acalcvm(self):
		"""Test acalcvm integer overflow in mod  - Array code bytes - Div by zero.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('B', [1]*10)
		data = bytes(data)
		dataout = array.array('B', [0]*10)
		dataout = bytes(dataout)

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('x % y', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0])



	########################################################
	def test_intoverflow_math_factorial_1_acalcvm(self):
		"""Test acalcvm integer overflow in math.factorial  - Array code bytes - greater than max.
		"""
		# Template name: intoverflow_template_1ops
		data = array.array('B', [self.MaxLimit]*10)
		data = bytes(data)
		dataout = array.array('B', [0]*10)
		dataout = bytes(dataout)

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.factorial(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


##############################################################################

##############################################################################
class acalcvm_floaterror_f(unittest.TestCase):
	"""Test for floating point overflow operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'f'
		self.MaxLimit = arrayfunc.arraylimits.f_max
		self.MinLimit = arrayfunc.arraylimits.f_min



	########################################################
	def test_floaterror_math_acos_acalcvm(self):
		"""Test acalcvm floating point error in math.acos  - Array code f.
		"""
		# Template name: floaterror_template_1ops
		data = array.array('f', range(-10,10))
		dataout = array.array('f', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.acos(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


	########################################################
	def test_floaterror_math_acosh_acalcvm(self):
		"""Test acalcvm floating point error in math.acosh  - Array code f.
		"""
		# Template name: floaterror_template_1ops
		data = array.array('f', range(-10,10))
		dataout = array.array('f', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.acosh(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


	########################################################
	def test_floaterror_math_asin_acalcvm(self):
		"""Test acalcvm floating point error in math.asin  - Array code f.
		"""
		# Template name: floaterror_template_1ops
		data = array.array('f', range(-10,10))
		dataout = array.array('f', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.asin(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


	########################################################
	def test_floaterror_math_atanh_acalcvm(self):
		"""Test acalcvm floating point error in math.atanh  - Array code f.
		"""
		# Template name: floaterror_template_1ops
		data = array.array('f', range(-10,10))
		dataout = array.array('f', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atanh(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


	########################################################
	def test_floaterror_math_fmod_acalcvm(self):
		"""Test acalcvm floating point error in math.fmod  - Array code f.
		"""
		# Template name: floaterror_template_2ops
		data = array.array('f', [-10.5,0.0,10.4])
		dataout = array.array('f', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0.0])


	########################################################
	def test_floaterror_math_gamma_acalcvm(self):
		"""Test acalcvm floating point error in math.gamma  - Array code f.
		"""
		# Template name: floaterror_template_1ops
		data = array.array('f', range(-10,10))
		dataout = array.array('f', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.gamma(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


	########################################################
	def test_floaterror_math_lgamma_acalcvm(self):
		"""Test acalcvm floating point error in math.lgamma  - Array code f.
		"""
		# Template name: floaterror_template_1ops
		data = array.array('f', range(-10,10))
		dataout = array.array('f', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.lgamma(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


	########################################################
	def test_floaterror_math_log_acalcvm(self):
		"""Test acalcvm floating point error in math.log  - Array code f.
		"""
		# Template name: floaterror_template_1ops
		data = array.array('f', range(-10,10))
		dataout = array.array('f', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


	########################################################
	def test_floaterror_math_log10_acalcvm(self):
		"""Test acalcvm floating point error in math.log10  - Array code f.
		"""
		# Template name: floaterror_template_1ops
		data = array.array('f', range(-10,10))
		dataout = array.array('f', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log10(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


	########################################################
	def test_floaterror_math_log1p_acalcvm(self):
		"""Test acalcvm floating point error in math.log1p  - Array code f.
		"""
		# Template name: floaterror_template_1ops
		data = array.array('f', range(-10,10))
		dataout = array.array('f', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log1p(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


	########################################################
	def test_floaterror_math_log2_acalcvm(self):
		"""Test acalcvm floating point error in math.log2  - Array code f.
		"""
		# Template name: floaterror_template_1ops
		data = array.array('f', range(-10,10))
		dataout = array.array('f', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log2(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


	########################################################
	def test_floaterror_math_pow_acalcvm(self):
		"""Test acalcvm floating point error in math.pow  - Array code f.
		"""
		# Template name: floaterror_template_2ops
		data = array.array('f', [-10.5,0.0,10.4])
		dataout = array.array('f', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-4.5])


	########################################################
	def test_floaterror_math_sqrt_acalcvm(self):
		"""Test acalcvm floating point error in math.sqrt  - Array code f.
		"""
		# Template name: floaterror_template_1ops
		data = array.array('f', range(-10,10))
		dataout = array.array('f', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.sqrt(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])

##############################################################################

##############################################################################
class acalcvm_floaterror_d(unittest.TestCase):
	"""Test for floating point overflow operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'd'
		self.MaxLimit = arrayfunc.arraylimits.d_max
		self.MinLimit = arrayfunc.arraylimits.d_min



	########################################################
	def test_floaterror_math_acos_acalcvm(self):
		"""Test acalcvm floating point error in math.acos  - Array code d.
		"""
		# Template name: floaterror_template_1ops
		data = array.array('d', range(-10,10))
		dataout = array.array('d', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.acos(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


	########################################################
	def test_floaterror_math_acosh_acalcvm(self):
		"""Test acalcvm floating point error in math.acosh  - Array code d.
		"""
		# Template name: floaterror_template_1ops
		data = array.array('d', range(-10,10))
		dataout = array.array('d', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.acosh(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


	########################################################
	def test_floaterror_math_asin_acalcvm(self):
		"""Test acalcvm floating point error in math.asin  - Array code d.
		"""
		# Template name: floaterror_template_1ops
		data = array.array('d', range(-10,10))
		dataout = array.array('d', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.asin(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


	########################################################
	def test_floaterror_math_atanh_acalcvm(self):
		"""Test acalcvm floating point error in math.atanh  - Array code d.
		"""
		# Template name: floaterror_template_1ops
		data = array.array('d', range(-10,10))
		dataout = array.array('d', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.atanh(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


	########################################################
	def test_floaterror_math_fmod_acalcvm(self):
		"""Test acalcvm floating point error in math.fmod  - Array code d.
		"""
		# Template name: floaterror_template_2ops
		data = array.array('d', [-10.5,0.0,10.4])
		dataout = array.array('d', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([0.0])


	########################################################
	def test_floaterror_math_gamma_acalcvm(self):
		"""Test acalcvm floating point error in math.gamma  - Array code d.
		"""
		# Template name: floaterror_template_1ops
		data = array.array('d', range(-10,10))
		dataout = array.array('d', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.gamma(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


	########################################################
	def test_floaterror_math_lgamma_acalcvm(self):
		"""Test acalcvm floating point error in math.lgamma  - Array code d.
		"""
		# Template name: floaterror_template_1ops
		data = array.array('d', range(-10,10))
		dataout = array.array('d', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.lgamma(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


	########################################################
	def test_floaterror_math_log_acalcvm(self):
		"""Test acalcvm floating point error in math.log  - Array code d.
		"""
		# Template name: floaterror_template_1ops
		data = array.array('d', range(-10,10))
		dataout = array.array('d', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


	########################################################
	def test_floaterror_math_log10_acalcvm(self):
		"""Test acalcvm floating point error in math.log10  - Array code d.
		"""
		# Template name: floaterror_template_1ops
		data = array.array('d', range(-10,10))
		dataout = array.array('d', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log10(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


	########################################################
	def test_floaterror_math_log1p_acalcvm(self):
		"""Test acalcvm floating point error in math.log1p  - Array code d.
		"""
		# Template name: floaterror_template_1ops
		data = array.array('d', range(-10,10))
		dataout = array.array('d', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log1p(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


	########################################################
	def test_floaterror_math_log2_acalcvm(self):
		"""Test acalcvm floating point error in math.log2  - Array code d.
		"""
		# Template name: floaterror_template_1ops
		data = array.array('d', range(-10,10))
		dataout = array.array('d', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.log2(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


	########################################################
	def test_floaterror_math_pow_acalcvm(self):
		"""Test acalcvm floating point error in math.pow  - Array code d.
		"""
		# Template name: floaterror_template_2ops
		data = array.array('d', [-10.5,0.0,10.4])
		dataout = array.array('d', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([-4.5])


	########################################################
	def test_floaterror_math_sqrt_acalcvm(self):
		"""Test acalcvm floating point error in math.sqrt  - Array code d.
		"""
		# Template name: floaterror_template_1ops
		data = array.array('d', range(-10,10))
		dataout = array.array('d', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('math.sqrt(x)', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])

##############################################################################

##############################################################################
class acalcvm_ovfl_param_b(unittest.TestCase):
	"""Test for basic operator function.
	"""
	# Template name: int_template_ovfl_param

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'b'
		self.MaxLimit = arrayfunc.arraylimits.b_max
		self.MinLimit = arrayfunc.arraylimits.b_min

		self.data = array.array('b', [0, 1, 2, 3, 4, 5] * 10)
		
		self.dataout = array.array('b', [0]*len(self.data))
		


	########################################################
	def test_int_ovfl_param_max_01_acalcvm(self):
		"""Test acalcvm overflow of parameters with max value and overflow checking on - Array code b.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MaxLimit - 5], disovfl=False)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MaxLimit + 1], disovfl=False)


	########################################################
	def test_int_ovfl_param_max_02_acalcvm(self):
		"""Test acalcvm overflow of parameters with max value and overflow checking off - Array code b.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MaxLimit - 5], disovfl=True)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MaxLimit + 1], disovfl=True)


	########################################################
	def test_int_ovfl_param_min_03_acalcvm(self):
		"""Test acalcvm overflow of parameters with min value and overflow checking on - Array code b.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MinLimit], disovfl=False)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MinLimit - 1], disovfl=False)


	########################################################
	def test_int_ovfl_param_min_04_acalcvm(self):
		"""Test acalcvm overflow of parameters with min value and overflow checking off - Array code b.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MinLimit], disovfl=True)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MinLimit - 1], disovfl=True)


##############################################################################

##############################################################################
class acalcvm_ovfl_param_B(unittest.TestCase):
	"""Test for basic operator function.
	"""
	# Template name: int_template_ovfl_param

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'
		self.MaxLimit = arrayfunc.arraylimits.B_max
		self.MinLimit = arrayfunc.arraylimits.B_min

		self.data = array.array('B', [0, 1, 2, 3, 4, 5] * 10)
		
		self.dataout = array.array('B', [0]*len(self.data))
		


	########################################################
	def test_int_ovfl_param_max_01_acalcvm(self):
		"""Test acalcvm overflow of parameters with max value and overflow checking on - Array code B.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MaxLimit - 5], disovfl=False)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MaxLimit + 1], disovfl=False)


	########################################################
	def test_int_ovfl_param_max_02_acalcvm(self):
		"""Test acalcvm overflow of parameters with max value and overflow checking off - Array code B.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MaxLimit - 5], disovfl=True)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MaxLimit + 1], disovfl=True)


	########################################################
	def test_int_ovfl_param_min_03_acalcvm(self):
		"""Test acalcvm overflow of parameters with min value and overflow checking on - Array code B.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MinLimit], disovfl=False)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MinLimit - 1], disovfl=False)


	########################################################
	def test_int_ovfl_param_min_04_acalcvm(self):
		"""Test acalcvm overflow of parameters with min value and overflow checking off - Array code B.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MinLimit], disovfl=True)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MinLimit - 1], disovfl=True)


##############################################################################

##############################################################################
class acalcvm_ovfl_param_h(unittest.TestCase):
	"""Test for basic operator function.
	"""
	# Template name: int_template_ovfl_param

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'h'
		self.MaxLimit = arrayfunc.arraylimits.h_max
		self.MinLimit = arrayfunc.arraylimits.h_min

		self.data = array.array('h', [0, 1, 2, 3, 4, 5] * 10)
		
		self.dataout = array.array('h', [0]*len(self.data))
		


	########################################################
	def test_int_ovfl_param_max_01_acalcvm(self):
		"""Test acalcvm overflow of parameters with max value and overflow checking on - Array code h.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MaxLimit - 5], disovfl=False)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MaxLimit + 1], disovfl=False)


	########################################################
	def test_int_ovfl_param_max_02_acalcvm(self):
		"""Test acalcvm overflow of parameters with max value and overflow checking off - Array code h.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MaxLimit - 5], disovfl=True)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MaxLimit + 1], disovfl=True)


	########################################################
	def test_int_ovfl_param_min_03_acalcvm(self):
		"""Test acalcvm overflow of parameters with min value and overflow checking on - Array code h.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MinLimit], disovfl=False)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MinLimit - 1], disovfl=False)


	########################################################
	def test_int_ovfl_param_min_04_acalcvm(self):
		"""Test acalcvm overflow of parameters with min value and overflow checking off - Array code h.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MinLimit], disovfl=True)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MinLimit - 1], disovfl=True)


##############################################################################

##############################################################################
class acalcvm_ovfl_param_H(unittest.TestCase):
	"""Test for basic operator function.
	"""
	# Template name: int_template_ovfl_param

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'H'
		self.MaxLimit = arrayfunc.arraylimits.H_max
		self.MinLimit = arrayfunc.arraylimits.H_min

		self.data = array.array('H', [0, 1, 2, 3, 4, 5] * 10)
		
		self.dataout = array.array('H', [0]*len(self.data))
		


	########################################################
	def test_int_ovfl_param_max_01_acalcvm(self):
		"""Test acalcvm overflow of parameters with max value and overflow checking on - Array code H.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MaxLimit - 5], disovfl=False)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MaxLimit + 1], disovfl=False)


	########################################################
	def test_int_ovfl_param_max_02_acalcvm(self):
		"""Test acalcvm overflow of parameters with max value and overflow checking off - Array code H.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MaxLimit - 5], disovfl=True)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MaxLimit + 1], disovfl=True)


	########################################################
	def test_int_ovfl_param_min_03_acalcvm(self):
		"""Test acalcvm overflow of parameters with min value and overflow checking on - Array code H.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MinLimit], disovfl=False)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MinLimit - 1], disovfl=False)


	########################################################
	def test_int_ovfl_param_min_04_acalcvm(self):
		"""Test acalcvm overflow of parameters with min value and overflow checking off - Array code H.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MinLimit], disovfl=True)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MinLimit - 1], disovfl=True)


##############################################################################

##############################################################################
class acalcvm_ovfl_param_i(unittest.TestCase):
	"""Test for basic operator function.
	"""
	# Template name: int_template_ovfl_param

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'i'
		self.MaxLimit = arrayfunc.arraylimits.i_max
		self.MinLimit = arrayfunc.arraylimits.i_min

		self.data = array.array('i', [0, 1, 2, 3, 4, 5] * 10)
		
		self.dataout = array.array('i', [0]*len(self.data))
		


	########################################################
	def test_int_ovfl_param_max_01_acalcvm(self):
		"""Test acalcvm overflow of parameters with max value and overflow checking on - Array code i.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MaxLimit - 5], disovfl=False)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MaxLimit + 1], disovfl=False)


	########################################################
	def test_int_ovfl_param_max_02_acalcvm(self):
		"""Test acalcvm overflow of parameters with max value and overflow checking off - Array code i.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MaxLimit - 5], disovfl=True)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MaxLimit + 1], disovfl=True)


	########################################################
	def test_int_ovfl_param_min_03_acalcvm(self):
		"""Test acalcvm overflow of parameters with min value and overflow checking on - Array code i.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MinLimit], disovfl=False)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MinLimit - 1], disovfl=False)


	########################################################
	def test_int_ovfl_param_min_04_acalcvm(self):
		"""Test acalcvm overflow of parameters with min value and overflow checking off - Array code i.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MinLimit], disovfl=True)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MinLimit - 1], disovfl=True)


##############################################################################

##############################################################################
class acalcvm_ovfl_param_I(unittest.TestCase):
	"""Test for basic operator function.
	"""
	# Template name: int_template_ovfl_param

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'I'
		self.MaxLimit = arrayfunc.arraylimits.I_max
		self.MinLimit = arrayfunc.arraylimits.I_min

		self.data = array.array('I', [0, 1, 2, 3, 4, 5] * 10)
		
		self.dataout = array.array('I', [0]*len(self.data))
		


	########################################################
	def test_int_ovfl_param_max_01_acalcvm(self):
		"""Test acalcvm overflow of parameters with max value and overflow checking on - Array code I.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MaxLimit - 5], disovfl=False)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MaxLimit + 1], disovfl=False)


	########################################################
	def test_int_ovfl_param_max_02_acalcvm(self):
		"""Test acalcvm overflow of parameters with max value and overflow checking off - Array code I.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MaxLimit - 5], disovfl=True)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MaxLimit + 1], disovfl=True)


	########################################################
	def test_int_ovfl_param_min_03_acalcvm(self):
		"""Test acalcvm overflow of parameters with min value and overflow checking on - Array code I.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MinLimit], disovfl=False)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MinLimit - 1], disovfl=False)


	########################################################
	def test_int_ovfl_param_min_04_acalcvm(self):
		"""Test acalcvm overflow of parameters with min value and overflow checking off - Array code I.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MinLimit], disovfl=True)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MinLimit - 1], disovfl=True)


##############################################################################

##############################################################################
class acalcvm_ovfl_param_l(unittest.TestCase):
	"""Test for basic operator function.
	"""
	# Template name: int_template_ovfl_param

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'l'
		self.MaxLimit = arrayfunc.arraylimits.l_max
		self.MinLimit = arrayfunc.arraylimits.l_min

		self.data = array.array('l', [0, 1, 2, 3, 4, 5] * 10)
		
		self.dataout = array.array('l', [0]*len(self.data))
		


	########################################################
	def test_int_ovfl_param_max_01_acalcvm(self):
		"""Test acalcvm overflow of parameters with max value and overflow checking on - Array code l.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MaxLimit - 5], disovfl=False)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MaxLimit + 1], disovfl=False)


	########################################################
	def test_int_ovfl_param_max_02_acalcvm(self):
		"""Test acalcvm overflow of parameters with max value and overflow checking off - Array code l.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MaxLimit - 5], disovfl=True)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MaxLimit + 1], disovfl=True)


	########################################################
	def test_int_ovfl_param_min_03_acalcvm(self):
		"""Test acalcvm overflow of parameters with min value and overflow checking on - Array code l.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MinLimit], disovfl=False)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MinLimit - 1], disovfl=False)


	########################################################
	def test_int_ovfl_param_min_04_acalcvm(self):
		"""Test acalcvm overflow of parameters with min value and overflow checking off - Array code l.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MinLimit], disovfl=True)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MinLimit - 1], disovfl=True)


##############################################################################

##############################################################################
class acalcvm_ovfl_param_L(unittest.TestCase):
	"""Test for basic operator function.
	"""
	# Template name: int_template_ovfl_param

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'L'
		self.MaxLimit = arrayfunc.arraylimits.L_max
		self.MinLimit = arrayfunc.arraylimits.L_min

		self.data = array.array('L', [0, 1, 2, 3, 4, 5] * 10)
		
		self.dataout = array.array('L', [0]*len(self.data))
		


	########################################################
	def test_int_ovfl_param_max_01_acalcvm(self):
		"""Test acalcvm overflow of parameters with max value and overflow checking on - Array code L.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MaxLimit - 5], disovfl=False)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MaxLimit + 1], disovfl=False)


	########################################################
	def test_int_ovfl_param_max_02_acalcvm(self):
		"""Test acalcvm overflow of parameters with max value and overflow checking off - Array code L.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MaxLimit - 5], disovfl=True)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MaxLimit + 1], disovfl=True)


	########################################################
	def test_int_ovfl_param_min_03_acalcvm(self):
		"""Test acalcvm overflow of parameters with min value and overflow checking on - Array code L.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MinLimit], disovfl=False)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MinLimit - 1], disovfl=False)


	########################################################
	def test_int_ovfl_param_min_04_acalcvm(self):
		"""Test acalcvm overflow of parameters with min value and overflow checking off - Array code L.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MinLimit], disovfl=True)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MinLimit - 1], disovfl=True)


##############################################################################

##############################################################################
class acalcvm_ovfl_param_q(unittest.TestCase):
	"""Test for basic operator function.
	"""
	# Template name: int_template_ovfl_param

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'q'
		self.MaxLimit = arrayfunc.arraylimits.q_max
		self.MinLimit = arrayfunc.arraylimits.q_min

		self.data = array.array('q', [0, 1, 2, 3, 4, 5] * 10)
		
		self.dataout = array.array('q', [0]*len(self.data))
		


	########################################################
	def test_int_ovfl_param_max_01_acalcvm(self):
		"""Test acalcvm overflow of parameters with max value and overflow checking on - Array code q.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MaxLimit - 5], disovfl=False)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MaxLimit + 1], disovfl=False)


	########################################################
	def test_int_ovfl_param_max_02_acalcvm(self):
		"""Test acalcvm overflow of parameters with max value and overflow checking off - Array code q.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MaxLimit - 5], disovfl=True)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MaxLimit + 1], disovfl=True)


	########################################################
	def test_int_ovfl_param_min_03_acalcvm(self):
		"""Test acalcvm overflow of parameters with min value and overflow checking on - Array code q.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MinLimit], disovfl=False)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MinLimit - 1], disovfl=False)


	########################################################
	def test_int_ovfl_param_min_04_acalcvm(self):
		"""Test acalcvm overflow of parameters with min value and overflow checking off - Array code q.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MinLimit], disovfl=True)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MinLimit - 1], disovfl=True)


##############################################################################

##############################################################################
class acalcvm_ovfl_param_Q(unittest.TestCase):
	"""Test for basic operator function.
	"""
	# Template name: int_template_ovfl_param

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'Q'
		self.MaxLimit = arrayfunc.arraylimits.Q_max
		self.MinLimit = arrayfunc.arraylimits.Q_min

		self.data = array.array('Q', [0, 1, 2, 3, 4, 5] * 10)
		
		self.dataout = array.array('Q', [0]*len(self.data))
		


	########################################################
	def test_int_ovfl_param_max_01_acalcvm(self):
		"""Test acalcvm overflow of parameters with max value and overflow checking on - Array code Q.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MaxLimit - 5], disovfl=False)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MaxLimit + 1], disovfl=False)


	########################################################
	def test_int_ovfl_param_max_02_acalcvm(self):
		"""Test acalcvm overflow of parameters with max value and overflow checking off - Array code Q.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MaxLimit - 5], disovfl=True)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MaxLimit + 1], disovfl=True)


	########################################################
	def test_int_ovfl_param_min_03_acalcvm(self):
		"""Test acalcvm overflow of parameters with min value and overflow checking on - Array code Q.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MinLimit], disovfl=False)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MinLimit - 1], disovfl=False)


	########################################################
	def test_int_ovfl_param_min_04_acalcvm(self):
		"""Test acalcvm overflow of parameters with min value and overflow checking off - Array code Q.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MinLimit], disovfl=True)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MinLimit - 1], disovfl=True)


##############################################################################

##############################################################################
class acalcvm_ovfl_param_bytes(unittest.TestCase):
	"""Test for basic operator function.
	"""
	# Template name: int_template_ovfl_param

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'
		self.MaxLimit = arrayfunc.arraylimits.B_max
		self.MinLimit = arrayfunc.arraylimits.B_min

		self.data = array.array('B', [0, 1, 2, 3, 4, 5] * 10)
		self.data = bytes(self.data)
		self.dataout = array.array('B', [0]*len(self.data))
		self.dataout = bytes(self.dataout)


	########################################################
	def test_int_ovfl_param_max_01_acalcvm(self):
		"""Test acalcvm overflow of parameters with max value and overflow checking on - Array code bytes.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MaxLimit - 5], disovfl=False)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MaxLimit + 1], disovfl=False)


	########################################################
	def test_int_ovfl_param_max_02_acalcvm(self):
		"""Test acalcvm overflow of parameters with max value and overflow checking off - Array code bytes.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MaxLimit - 5], disovfl=True)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MaxLimit + 1], disovfl=True)


	########################################################
	def test_int_ovfl_param_min_03_acalcvm(self):
		"""Test acalcvm overflow of parameters with min value and overflow checking on - Array code bytes.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MinLimit], disovfl=False)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MinLimit - 1], disovfl=False)


	########################################################
	def test_int_ovfl_param_min_04_acalcvm(self):
		"""Test acalcvm overflow of parameters with min value and overflow checking off - Array code bytes.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MinLimit], disovfl=True)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MinLimit - 1], disovfl=True)


##############################################################################

##############################################################################
class acalcvm_nan_data_add_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_add_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-25.0])


	########################################################
	def test_nan_add_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat(-25.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_add_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-25.0])


	########################################################
	def test_inf_add_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat(-25.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_add_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-25.0])


	########################################################
	def test_ninf_add_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat(-25.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_add_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_add_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_nan_add_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_add_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_inf_add_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_add_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_ninf_add_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_add_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_add_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_nan_add_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_add_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_inf_add_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_add_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_ninf_add_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_add_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_add_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_nan_add_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_add_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_inf_add_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_add_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_ninf_add_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_add_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_add_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 25.0])


	########################################################
	def test_nan_add_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat( 25.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_add_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 25.0])


	########################################################
	def test_inf_add_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat( 25.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_add_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 25.0])


	########################################################
	def test_ninf_add_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat( 25.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_sub_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_sub_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_nan_sub_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_sub_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_inf_sub_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_sub_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_ninf_sub_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_sub_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_sub_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_nan_sub_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_sub_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_inf_sub_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_sub_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_ninf_sub_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_sub_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_sub_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_nan_sub_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_sub_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_inf_sub_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_sub_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_ninf_sub_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_sub_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_sub_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_nan_sub_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_sub_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_inf_sub_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_sub_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_ninf_sub_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_sub_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_sub_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_nan_sub_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_sub_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_inf_sub_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_sub_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_ninf_sub_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_mult_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_mult_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-3.0])


	########################################################
	def test_nan_mult_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat(-3.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_mult_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-3.0])


	########################################################
	def test_inf_mult_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat(-3.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_mult_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-3.0])


	########################################################
	def test_ninf_mult_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat(-3.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_mult_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_mult_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -2.0])


	########################################################
	def test_nan_mult_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( -2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_mult_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -2.0])


	########################################################
	def test_inf_mult_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( -2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_mult_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -2.0])


	########################################################
	def test_ninf_mult_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( -2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_mult_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_mult_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_nan_mult_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_mult_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_inf_mult_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_mult_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_ninf_mult_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_mult_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_mult_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_nan_mult_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_mult_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_inf_mult_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_mult_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_ninf_mult_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_mult_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_mult_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_nan_mult_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_mult_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_inf_mult_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_mult_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_ninf_mult_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_mult_5_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_mult_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_nan_mult_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_mult_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_inf_mult_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_mult_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_ninf_mult_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_mult_6_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_mult_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 3.0])


	########################################################
	def test_nan_mult_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( 3.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_mult_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 3.0])


	########################################################
	def test_inf_mult_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( 3.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_mult_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 3.0])


	########################################################
	def test_ninf_mult_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( 3.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_div_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_div_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_nan_div_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x / y for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_div_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_inf_div_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x / y for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_div_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_ninf_div_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x / y for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_div_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_div_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_nan_div_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x / y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_div_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_inf_div_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x / y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_div_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_ninf_div_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x / y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_div_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_div_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_nan_div_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x / y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_div_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_inf_div_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x / y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_div_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_ninf_div_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x / y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_div_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_div_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_nan_div_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x / y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_div_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_inf_div_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x / y for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_div_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_ninf_div_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x / y for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_floordiv_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_floordiv_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_nan_floordiv_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x // y for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_floordiv_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_param_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_inf_floordiv_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)



	########################################################
	def test_ninf_floordiv_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_param_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_ninf_floordiv_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)


##############################################################################

##############################################################################
class acalcvm_nan_data_floordiv_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_floordiv_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_nan_floordiv_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x // y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_floordiv_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_param_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_inf_floordiv_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)



	########################################################
	def test_ninf_floordiv_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_param_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_ninf_floordiv_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


##############################################################################

##############################################################################
class acalcvm_nan_data_floordiv_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_floordiv_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_nan_floordiv_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x // y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_floordiv_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_param_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_inf_floordiv_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)



	########################################################
	def test_ninf_floordiv_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_param_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_ninf_floordiv_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


##############################################################################

##############################################################################
class acalcvm_nan_data_floordiv_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_floordiv_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_nan_floordiv_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x // y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_floordiv_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_param_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_inf_floordiv_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)



	########################################################
	def test_ninf_floordiv_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_param_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_ninf_floordiv_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


##############################################################################

##############################################################################
class acalcvm_nan_data_mod_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_mod_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_af_mod_error_param_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2.0])

		# This is the actual test. We always expect NaN to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_nan_mod_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_mod_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_af_mod_error_param_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2.0])

		# This is the actual test. We always expect NaN to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_inf_mod_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_mod_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_af_mod_error_param_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2.0])

		# This is the actual test. We always expect NaN to raise errors.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_ninf_mod_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_mod_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_mod_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_af_mod_error_param_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test. We always expect NaN to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_nan_mod_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_mod_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_af_mod_error_param_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test. We always expect NaN to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_inf_mod_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_mod_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_af_mod_error_param_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test. We always expect NaN to raise errors.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_ninf_mod_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_mod_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_mod_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_af_mod_error_param_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test. We always expect NaN to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_nan_mod_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_mod_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_af_mod_error_param_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test. We always expect NaN to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_inf_mod_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_mod_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_af_mod_error_param_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test. We always expect NaN to raise errors.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_ninf_mod_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_mod_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_mod_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_af_mod_error_param_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test. We always expect NaN to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_nan_mod_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_mod_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_af_mod_error_param_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test. We always expect NaN to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_inf_mod_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_mod_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_af_mod_error_param_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test. We always expect NaN to raise errors.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_ninf_mod_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_uadd_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_uadd_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('+x', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_uadd_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [+x for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_uadd_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('+x', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_uadd_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [+x for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_uadd_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('+x', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_uadd_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [+x for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_usub_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_usub_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('-x', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_usub_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [-x for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_usub_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('-x', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_usub_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [-x for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_usub_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('-x', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_usub_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [-x for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_pow_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_pow_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.datanan), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([0.0])
		else:
			eqnd.execute([0.0])


	########################################################
	def test_nan_pow_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.datanan), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_pow_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.datainf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([0.0])
		else:
			eqnd.execute([0.0])


	########################################################
	def test_inf_pow_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.datainf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_pow_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.dataninf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([0.0])
		else:
			eqnd.execute([0.0])


	########################################################
	def test_ninf_pow_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.dataninf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_pow_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_pow_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 1.0])
		else:
			eqnd.execute([ 1.0])


	########################################################
	def test_nan_pow_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_pow_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 1.0])
		else:
			eqnd.execute([ 1.0])


	########################################################
	def test_inf_pow_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_pow_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 1.0])
		else:
			eqnd.execute([ 1.0])


	########################################################
	def test_ninf_pow_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_pow_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_pow_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 2.0])
		else:
			eqnd.execute([ 2.0])


	########################################################
	def test_nan_pow_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_pow_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 2.0])
		else:
			eqnd.execute([ 2.0])


	########################################################
	def test_inf_pow_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_pow_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 2.0])
		else:
			eqnd.execute([ 2.0])


	########################################################
	def test_ninf_pow_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_abs_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_abs_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [abs(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_abs_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_abs_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [abs(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_abs_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_abs_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [abs(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_abs_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_acos_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_acos_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.acos(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_acos_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.acos(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.acos(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_acos_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.acos(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_acos_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.acos(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_ninf_math_acos_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.acos(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_acos_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.acos(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_acosh_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [1.0] * 10)
		self.dataok = array.array('f', [1.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_acosh_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.acosh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_acosh_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.acosh(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.acosh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_acosh_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.acosh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_acosh_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.acosh(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.acosh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_acosh_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.acosh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_acosh_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.acosh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_asin_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_asin_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.asin(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_asin_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.asin(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.asin(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_asin_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.asin(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_asin_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.asin(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_ninf_math_asin_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.asin(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_asin_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.asin(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_asinh_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_asinh_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.asinh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_asinh_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.asinh(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.asinh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_asinh_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.asinh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_asinh_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.asinh(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.asinh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_asinh_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.asinh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_asinh_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.asinh(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.asinh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_atan_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.atan(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_atan_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.atan(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_atan_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.atan(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.atan(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.atan(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.atan(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_atan2_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([-2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_nan_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and param data of -2.0  - Array code f.
		"""
		# Template name: nan_data_noerror_template
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([-2.0])


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and param data of -2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and param data of -2.0  - Array code f.
		"""
		# Template name: nan_data_noerror_template
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([-2.0])


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and param data of -2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_atan2_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_nan_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Template name: nan_data_noerror_template
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0])


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Template name: nan_data_noerror_template
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0])


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_atan2_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_nan_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Template name: nan_data_noerror_template
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0])


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Template name: nan_data_noerror_template
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0])


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_atan2_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_nan_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Template name: nan_data_noerror_template
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Template name: nan_data_noerror_template
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_atan2_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_nan_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and param data of  2.0  - Array code f.
		"""
		# Template name: nan_data_noerror_template
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0])


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and param data of  2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and param data of  2.0  - Array code f.
		"""
		# Template name: nan_data_noerror_template
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0])


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and param data of  2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_atanh_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atanh_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.atanh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_atanh_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atanh(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.atanh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_atanh_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.atanh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_atanh_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.atanh(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_ninf_math_atanh_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.atanh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_atanh_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.atanh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_ceil_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_ceil_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.ceil(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_ceil_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.ceil(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_inf_math_ceil_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.ceil(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_ceil_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.ceil(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_ninf_math_ceil_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.ceil(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_ceil_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.ceil(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_copysign_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_copysign_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([-3.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-3.0])


	########################################################
	def test_nan_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-3.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([-3.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_copysign_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([-3.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-3.0])


	########################################################
	def test_inf_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-3.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([-3.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_copysign_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([-3.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-3.0])


	########################################################
	def test_ninf_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-3.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([-3.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_copysign_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_copysign_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_nan_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_copysign_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_inf_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_copysign_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_ninf_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_copysign_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_copysign_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_nan_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_copysign_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_inf_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_copysign_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_ninf_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_copysign_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_copysign_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_nan_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_copysign_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_inf_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_copysign_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_ninf_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_copysign_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_copysign_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 3.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 3.0])


	########################################################
	def test_nan_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 3.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 3.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_copysign_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 3.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 3.0])


	########################################################
	def test_inf_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 3.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 3.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_copysign_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 3.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 3.0])


	########################################################
	def test_ninf_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 3.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 3.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_cos_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_cos_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.cos(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_cos_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.cos(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.cos(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_cos_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.cos(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_cos_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.cos(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_ninf_math_cos_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.cos(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_cos_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.cos(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_cosh_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [1.0] * 10)
		self.dataok = array.array('f', [1.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_cosh_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.cosh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_cosh_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.cosh(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.cosh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_cosh_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.cosh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_cosh_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.cosh(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.cosh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_cosh_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.cosh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_cosh_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.cosh(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.cosh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_degrees_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_degrees_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.degrees(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_degrees_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.degrees(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.degrees(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_degrees_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.degrees(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_degrees_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.degrees(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.degrees(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_degrees_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.degrees(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_degrees_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.degrees(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.degrees(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_erf_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_erf_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.erf(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_erf_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.erf(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_erf_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.erf(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_erf_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.erf(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_erf_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.erf(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_erf_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.erf(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_erfc_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_erfc_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.erfc(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_erfc_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.erfc(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_erfc_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.erfc(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_erfc_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.erfc(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_erfc_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.erfc(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_erfc_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.erfc(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_exp_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_exp_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.exp(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_exp_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.exp(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.exp(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_exp_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.exp(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_exp_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.exp(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_ninf_math_exp_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [math.exp(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.exp(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_exp_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.exp(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.exp(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_expm1_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_expm1_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.expm1(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_expm1_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.expm1(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.expm1(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_expm1_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.expm1(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_expm1_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.expm1(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_ninf_math_expm1_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [math.expm1(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.expm1(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_expm1_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.expm1(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.expm1(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_fabs_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_fabs_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [math.fabs(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.fabs(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_fabs_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.fabs(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.fabs(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_fabs_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [math.fabs(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.fabs(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_fabs_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.fabs(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.fabs(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_fabs_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [math.fabs(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.fabs(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_fabs_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.fabs(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.fabs(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_floor_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_floor_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.floor(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_floor_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.floor(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_inf_math_floor_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.floor(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_floor_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.floor(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_ninf_math_floor_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.floor(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_floor_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.floor(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_fmod_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_fmod_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_fmoderror_param_template
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([-2.0])


		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([-2.0])
		else:
			eqnd.execute([-2.0])


	########################################################
	def test_nan_math_fmod_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_fmod_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_fmoderror_param_template
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([-2.0])


		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([-2.0])
		else:
			eqnd.execute([-2.0])


	########################################################
	def test_inf_math_fmod_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_fmod_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_fmoderror_param_template
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([-2.0])


		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([-2.0])
		else:
			eqnd.execute([-2.0])


	########################################################
	def test_ninf_math_fmod_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_fmod_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_fmod_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_fmoderror_param_template
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0])


		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ -1.0])
		else:
			eqnd.execute([ -1.0])


	########################################################
	def test_nan_math_fmod_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_fmod_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_fmoderror_param_template
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0])


		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ -1.0])
		else:
			eqnd.execute([ -1.0])


	########################################################
	def test_inf_math_fmod_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_fmod_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_fmoderror_param_template
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0])


		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ -1.0])
		else:
			eqnd.execute([ -1.0])


	########################################################
	def test_ninf_math_fmod_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_fmod_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_fmod_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_fmoderror_param_template
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])


		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 1.0])
		else:
			eqnd.execute([ 1.0])


	########################################################
	def test_nan_math_fmod_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_fmod_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_fmoderror_param_template
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])


		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 1.0])
		else:
			eqnd.execute([ 1.0])


	########################################################
	def test_inf_math_fmod_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_fmod_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_fmoderror_param_template
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])


		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 1.0])
		else:
			eqnd.execute([ 1.0])


	########################################################
	def test_ninf_math_fmod_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_fmod_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_fmod_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_fmoderror_param_template
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0])


		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 2.0])
		else:
			eqnd.execute([ 2.0])


	########################################################
	def test_nan_math_fmod_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_fmod_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_fmoderror_param_template
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0])


		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 2.0])
		else:
			eqnd.execute([ 2.0])


	########################################################
	def test_inf_math_fmod_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_fmod_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_fmoderror_param_template
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0])


		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 2.0])
		else:
			eqnd.execute([ 2.0])


	########################################################
	def test_ninf_math_fmod_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_gamma_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [1.0] * 10)
		self.dataok = array.array('f', [1.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_gamma_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.gamma(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_gamma_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.gamma(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_inf_math_gamma_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.gamma(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_gamma_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.gamma(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_ninf_math_gamma_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.gamma(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_gamma_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.gamma(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_hypot_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([-2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_nan_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([-2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_inf_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([-2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_ninf_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_hypot_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_nan_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_inf_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_ninf_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_hypot_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_nan_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_inf_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_ninf_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_hypot_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_nan_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_inf_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_ninf_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_hypot_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_nan_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_inf_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_ninf_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_ldexp_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([-2])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2])


	########################################################
	def test_nan_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-2))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([-2], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([-2])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2])


	########################################################
	def test_inf_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([-2], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([-2])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2])


	########################################################
	def test_ninf_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([-2], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_ldexp_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ -1])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1])


	########################################################
	def test_nan_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ -1])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1])


	########################################################
	def test_inf_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ -1])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1])


	########################################################
	def test_ninf_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_ldexp_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0])


	########################################################
	def test_nan_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0])


	########################################################
	def test_inf_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0])


	########################################################
	def test_ninf_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_ldexp_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 1])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1])


	########################################################
	def test_nan_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 1])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1])


	########################################################
	def test_inf_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 1])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1])


	########################################################
	def test_ninf_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_ldexp_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 2])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2])


	########################################################
	def test_nan_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 2])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2])


	########################################################
	def test_inf_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 2])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2])


	########################################################
	def test_ninf_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_lgamma_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [1.0] * 10)
		self.dataok = array.array('f', [1.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_lgamma_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.lgamma(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_lgamma_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.lgamma(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.lgamma(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_lgamma_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.lgamma(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_lgamma_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.lgamma(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.lgamma(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_lgamma_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.lgamma(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_lgamma_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.lgamma(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.lgamma(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_log_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [1.0] * 10)
		self.dataok = array.array('f', [1.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_log_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.log(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_log_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.log(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.log(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_log_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.log(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_log_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.log(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.log(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_log_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.log(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_log_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.log(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_log10_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [1.0] * 10)
		self.dataok = array.array('f', [1.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_log10_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.log10(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_log10_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.log10(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.log10(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_log10_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.log10(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_log10_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.log10(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.log10(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_log10_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.log10(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_log10_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.log10(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_log1p_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [1.0] * 10)
		self.dataok = array.array('f', [1.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_log1p_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.log1p(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_log1p_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.log1p(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.log1p(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_log1p_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.log1p(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_log1p_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.log1p(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.log1p(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_log1p_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.log1p(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_log1p_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.log1p(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_log2_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [1.0] * 10)
		self.dataok = array.array('f', [1.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_log2_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.log2(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_log2_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.log2(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.log2(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_log2_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.log2(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_log2_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.log2(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.log2(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_log2_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.log2(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_log2_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.log2(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_pow_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_pow_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([0.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([0.0])
		else:
			eqnd.execute([0.0])


	########################################################
	def test_nan_math_pow_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([0.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_pow_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([0.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([0.0])
		else:
			eqnd.execute([0.0])


	########################################################
	def test_inf_math_pow_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([0.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_pow_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([0.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([0.0])
		else:
			eqnd.execute([0.0])


	########################################################
	def test_ninf_math_pow_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([0.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_pow_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_pow_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 1.0])
		else:
			eqnd.execute([ 1.0])


	########################################################
	def test_nan_math_pow_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_pow_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 1.0])
		else:
			eqnd.execute([ 1.0])


	########################################################
	def test_inf_math_pow_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_pow_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 1.0])
		else:
			eqnd.execute([ 1.0])


	########################################################
	def test_ninf_math_pow_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_pow_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_pow_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code f.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 2.0])
		else:
			eqnd.execute([ 2.0])


	########################################################
	def test_nan_math_pow_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_pow_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 2.0])
		else:
			eqnd.execute([ 2.0])


	########################################################
	def test_inf_math_pow_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_pow_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code f.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 2.0])
		else:
			eqnd.execute([ 2.0])


	########################################################
	def test_ninf_math_pow_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_radians_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_radians_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.radians(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_radians_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.radians(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.radians(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_radians_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.radians(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_radians_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.radians(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.radians(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_radians_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.radians(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_radians_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.radians(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.radians(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_sin_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_sin_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.sin(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_sin_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.sin(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.sin(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_sin_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.sin(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_sin_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.sin(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_ninf_math_sin_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.sin(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_sin_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.sin(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_sinh_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_sinh_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.sinh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_sinh_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.sinh(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.sinh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_sinh_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.sinh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_sinh_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.sinh(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.sinh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_sinh_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.sinh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_sinh_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.sinh(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.sinh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_sqrt_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_sqrt_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.sqrt(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_sqrt_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.sqrt(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.sqrt(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_sqrt_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.sqrt(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_sqrt_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.sqrt(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.sqrt(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_sqrt_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.sqrt(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_sqrt_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.sqrt(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_tan_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_tan_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.tan(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_tan_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.tan(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.tan(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_tan_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.tan(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_tan_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.tan(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_ninf_math_tan_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.tan(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_tan_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.tan(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_tanh_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_tanh_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.tanh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_tanh_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.tanh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_tanh_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.tanh(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_tanh_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.tanh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_tanh_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.tanh(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_tanh_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.tanh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_trunc_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_trunc_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.trunc(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_trunc_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.trunc(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_inf_math_trunc_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.trunc(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_trunc_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.trunc(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_ninf_math_trunc_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.trunc(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_trunc_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.trunc(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_add_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_add_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-25.0])


	########################################################
	def test_nan_add_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat(-25.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_add_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-25.0])


	########################################################
	def test_inf_add_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat(-25.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_add_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-25.0])


	########################################################
	def test_ninf_add_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat(-25.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([-25.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_add_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_add_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_nan_add_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_add_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_inf_add_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_add_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_ninf_add_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_add_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_add_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_nan_add_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_add_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_inf_add_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_add_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_ninf_add_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_add_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_add_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_nan_add_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_add_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_inf_add_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_add_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_ninf_add_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_add_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_add_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 25.0])


	########################################################
	def test_nan_add_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat( 25.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_add_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 25.0])


	########################################################
	def test_inf_add_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat( 25.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_add_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 25.0])


	########################################################
	def test_ninf_add_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat( 25.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])
		eqnd.execute([ 25.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_sub_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_sub_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_nan_sub_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_sub_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_inf_sub_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_sub_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_ninf_sub_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_sub_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_sub_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_nan_sub_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_sub_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_inf_sub_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_sub_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_ninf_sub_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_sub_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_sub_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_nan_sub_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_sub_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_inf_sub_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_sub_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_ninf_sub_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_sub_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_sub_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_nan_sub_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_sub_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_inf_sub_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_sub_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_ninf_sub_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_sub_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_sub_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_nan_sub_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_sub_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_inf_sub_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_sub_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_ninf_sub_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x - y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_mult_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_mult_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-3.0])


	########################################################
	def test_nan_mult_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat(-3.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_mult_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-3.0])


	########################################################
	def test_inf_mult_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat(-3.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_mult_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-3.0])


	########################################################
	def test_ninf_mult_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat(-3.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([-3.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_mult_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_mult_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -2.0])


	########################################################
	def test_nan_mult_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( -2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_mult_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -2.0])


	########################################################
	def test_inf_mult_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( -2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_mult_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -2.0])


	########################################################
	def test_ninf_mult_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( -2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_mult_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_mult_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_nan_mult_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_mult_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_inf_mult_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_mult_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_ninf_mult_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_mult_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_mult_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_nan_mult_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_mult_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_inf_mult_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_mult_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_ninf_mult_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_mult_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_mult_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_nan_mult_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_mult_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_inf_mult_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_mult_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_ninf_mult_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_mult_5_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_mult_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_nan_mult_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_mult_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_inf_mult_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_mult_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_ninf_mult_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_mult_6_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_mult_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 3.0])


	########################################################
	def test_nan_mult_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( 3.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_mult_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 3.0])


	########################################################
	def test_inf_mult_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( 3.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_mult_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 3.0])


	########################################################
	def test_ninf_mult_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( 3.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x * y', 'x', ['y'])
		eqnd.execute([ 3.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_div_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_div_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_nan_div_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x / y for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_div_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_inf_div_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x / y for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_div_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_ninf_div_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x / y for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_div_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_div_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_nan_div_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x / y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_div_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_inf_div_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x / y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_div_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_ninf_div_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x / y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_div_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_div_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_nan_div_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x / y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_div_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_inf_div_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x / y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_div_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_ninf_div_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x / y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_div_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_div_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_nan_div_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x / y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_div_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_inf_div_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x / y for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_div_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_ninf_div_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x / y for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x / y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_floordiv_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_floordiv_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_nan_floordiv_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x // y for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_floordiv_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_param_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_inf_floordiv_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)



	########################################################
	def test_ninf_floordiv_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_param_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_ninf_floordiv_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)


##############################################################################

##############################################################################
class acalcvm_nan_data_floordiv_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_floordiv_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_nan_floordiv_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x // y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_floordiv_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_param_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_inf_floordiv_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)



	########################################################
	def test_ninf_floordiv_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_param_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_ninf_floordiv_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


##############################################################################

##############################################################################
class acalcvm_nan_data_floordiv_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_floordiv_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_nan_floordiv_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x // y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_floordiv_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_param_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_inf_floordiv_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)



	########################################################
	def test_ninf_floordiv_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_param_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_ninf_floordiv_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


##############################################################################

##############################################################################
class acalcvm_nan_data_floordiv_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_floordiv_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_nan_floordiv_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x // y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_floordiv_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_param_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_inf_floordiv_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)



	########################################################
	def test_ninf_floordiv_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_param_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_ninf_floordiv_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x // y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


##############################################################################

##############################################################################
class acalcvm_nan_data_mod_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_mod_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_af_mod_error_param_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2.0])

		# This is the actual test. We always expect NaN to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_nan_mod_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_mod_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_af_mod_error_param_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2.0])

		# This is the actual test. We always expect NaN to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_inf_mod_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_mod_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_af_mod_error_param_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2.0])

		# This is the actual test. We always expect NaN to raise errors.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_ninf_mod_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_mod_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_mod_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_af_mod_error_param_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test. We always expect NaN to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_nan_mod_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_mod_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_af_mod_error_param_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test. We always expect NaN to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_inf_mod_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_mod_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_af_mod_error_param_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test. We always expect NaN to raise errors.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_ninf_mod_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_mod_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_mod_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_af_mod_error_param_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test. We always expect NaN to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_nan_mod_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_mod_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_af_mod_error_param_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test. We always expect NaN to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_inf_mod_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_mod_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_af_mod_error_param_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test. We always expect NaN to raise errors.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_ninf_mod_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_mod_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_mod_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_af_mod_error_param_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test. We always expect NaN to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_nan_mod_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_mod_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_af_mod_error_param_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test. We always expect NaN to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_inf_mod_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_mod_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_af_mod_error_param_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test. We always expect NaN to raise errors.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_ninf_mod_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x % y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_uadd_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_uadd_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('+x', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_uadd_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [+x for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_uadd_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('+x', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_uadd_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [+x for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_uadd_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('+x', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_uadd_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [+x for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('+x', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_usub_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_usub_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('-x', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_usub_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [-x for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_usub_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('-x', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_usub_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [-x for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_usub_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('-x', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_usub_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [-x for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('-x', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_pow_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_pow_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.datanan), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([0.0])
		else:
			eqnd.execute([0.0])


	########################################################
	def test_nan_pow_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.datanan), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_pow_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.datainf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([0.0])
		else:
			eqnd.execute([0.0])


	########################################################
	def test_inf_pow_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.datainf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_pow_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.dataninf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([0.0])
		else:
			eqnd.execute([0.0])


	########################################################
	def test_ninf_pow_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.dataninf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([0.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_pow_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_pow_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 1.0])
		else:
			eqnd.execute([ 1.0])


	########################################################
	def test_nan_pow_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_pow_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 1.0])
		else:
			eqnd.execute([ 1.0])


	########################################################
	def test_inf_pow_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_pow_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 1.0])
		else:
			eqnd.execute([ 1.0])


	########################################################
	def test_ninf_pow_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_pow_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_pow_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 2.0])
		else:
			eqnd.execute([ 2.0])


	########################################################
	def test_nan_pow_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_pow_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 2.0])
		else:
			eqnd.execute([ 2.0])


	########################################################
	def test_inf_pow_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_pow_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 2.0])
		else:
			eqnd.execute([ 2.0])


	########################################################
	def test_ninf_pow_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x**y for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('x**y', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_abs_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_abs_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [abs(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_abs_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_abs_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [abs(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_abs_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_abs_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [abs(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_abs_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('abs(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_acos_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_acos_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.acos(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_acos_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.acos(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.acos(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_acos_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.acos(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_acos_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.acos(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_ninf_math_acos_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.acos(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_acos_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.acos(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_acosh_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [1.0] * 10)
		self.dataok = array.array('d', [1.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_acosh_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.acosh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_acosh_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.acosh(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.acosh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_acosh_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.acosh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_acosh_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.acosh(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.acosh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_acosh_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.acosh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_acosh_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.acosh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_asin_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_asin_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.asin(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_asin_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.asin(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.asin(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_asin_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.asin(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_asin_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.asin(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_ninf_math_asin_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.asin(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_asin_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.asin(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_asinh_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_asinh_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.asinh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_asinh_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.asinh(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.asinh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_asinh_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.asinh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_asinh_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.asinh(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.asinh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_asinh_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.asinh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_asinh_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.asinh(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.asinh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_atan_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.atan(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_atan_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.atan(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_atan_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.atan(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.atan(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.atan(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.atan(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_atan2_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([-2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_nan_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and param data of -2.0  - Array code d.
		"""
		# Template name: nan_data_noerror_template
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([-2.0])


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and param data of -2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and param data of -2.0  - Array code d.
		"""
		# Template name: nan_data_noerror_template
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([-2.0])


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and param data of -2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_atan2_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_nan_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Template name: nan_data_noerror_template
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0])


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Template name: nan_data_noerror_template
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0])


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_atan2_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_nan_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Template name: nan_data_noerror_template
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0])


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Template name: nan_data_noerror_template
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0])


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_atan2_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_nan_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Template name: nan_data_noerror_template
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Template name: nan_data_noerror_template
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_atan2_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_nan_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and param data of  2.0  - Array code d.
		"""
		# Template name: nan_data_noerror_template
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0])


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and param data of  2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and param data of  2.0  - Array code d.
		"""
		# Template name: nan_data_noerror_template
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0])


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and param data of  2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.atan2(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_atanh_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atanh_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.atanh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_atanh_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atanh(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.atanh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_atanh_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.atanh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_atanh_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.atanh(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_ninf_math_atanh_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.atanh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_atanh_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.atanh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_ceil_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_ceil_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.ceil(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_ceil_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.ceil(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_inf_math_ceil_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.ceil(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_ceil_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.ceil(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_ninf_math_ceil_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.ceil(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_ceil_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.ceil(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_copysign_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_copysign_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([-3.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-3.0])


	########################################################
	def test_nan_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-3.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([-3.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_copysign_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([-3.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-3.0])


	########################################################
	def test_inf_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-3.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([-3.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_copysign_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([-3.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-3.0])


	########################################################
	def test_ninf_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-3.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([-3.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_copysign_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_copysign_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_nan_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_copysign_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_inf_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_copysign_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_ninf_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_copysign_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_copysign_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_nan_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_copysign_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_inf_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_copysign_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_ninf_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_copysign_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_copysign_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_nan_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_copysign_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_inf_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_copysign_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_ninf_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_copysign_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_copysign_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 3.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 3.0])


	########################################################
	def test_nan_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 3.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 3.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_copysign_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 3.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 3.0])


	########################################################
	def test_inf_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 3.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 3.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_copysign_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 3.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 3.0])


	########################################################
	def test_ninf_math_copysign_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 3.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.copysign(x, y)', 'x', ['y'])
		eqnd.execute([ 3.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_cos_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_cos_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.cos(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_cos_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.cos(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.cos(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_cos_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.cos(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_cos_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.cos(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_ninf_math_cos_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.cos(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_cos_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.cos(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_cosh_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [1.0] * 10)
		self.dataok = array.array('d', [1.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_cosh_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.cosh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_cosh_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.cosh(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.cosh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_cosh_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.cosh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_cosh_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.cosh(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.cosh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_cosh_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.cosh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_cosh_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.cosh(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.cosh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_degrees_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_degrees_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.degrees(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_degrees_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.degrees(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.degrees(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_degrees_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.degrees(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_degrees_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.degrees(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.degrees(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_degrees_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.degrees(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_degrees_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.degrees(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.degrees(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_erf_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_erf_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.erf(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_erf_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.erf(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_erf_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.erf(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_erf_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.erf(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_erf_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.erf(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_erf_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.erf(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_erfc_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_erfc_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.erfc(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_erfc_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.erfc(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_erfc_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.erfc(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_erfc_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.erfc(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_erfc_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.erfc(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_erfc_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.erfc(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_exp_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_exp_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.exp(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_exp_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.exp(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.exp(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_exp_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.exp(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_exp_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.exp(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_ninf_math_exp_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [math.exp(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.exp(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_exp_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.exp(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.exp(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_expm1_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_expm1_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.expm1(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_expm1_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.expm1(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.expm1(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_expm1_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.expm1(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_expm1_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.expm1(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_ninf_math_expm1_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [math.expm1(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.expm1(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_expm1_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.expm1(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.expm1(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_fabs_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_fabs_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [math.fabs(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.fabs(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_fabs_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.fabs(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.fabs(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_fabs_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [math.fabs(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.fabs(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_fabs_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.fabs(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.fabs(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_fabs_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [math.fabs(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.fabs(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_fabs_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.fabs(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.fabs(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_floor_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_floor_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.floor(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_floor_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.floor(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_inf_math_floor_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.floor(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_floor_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.floor(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_ninf_math_floor_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.floor(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_floor_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.floor(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_fmod_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_fmod_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_fmoderror_param_template
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([-2.0])


		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([-2.0])
		else:
			eqnd.execute([-2.0])


	########################################################
	def test_nan_math_fmod_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_fmod_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_fmoderror_param_template
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([-2.0])


		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([-2.0])
		else:
			eqnd.execute([-2.0])


	########################################################
	def test_inf_math_fmod_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_fmod_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_fmoderror_param_template
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([-2.0])


		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([-2.0])
		else:
			eqnd.execute([-2.0])


	########################################################
	def test_ninf_math_fmod_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_fmod_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_fmod_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_fmoderror_param_template
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0])


		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ -1.0])
		else:
			eqnd.execute([ -1.0])


	########################################################
	def test_nan_math_fmod_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_fmod_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_fmoderror_param_template
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0])


		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ -1.0])
		else:
			eqnd.execute([ -1.0])


	########################################################
	def test_inf_math_fmod_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_fmod_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_fmoderror_param_template
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0])


		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ -1.0])
		else:
			eqnd.execute([ -1.0])


	########################################################
	def test_ninf_math_fmod_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_fmod_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_fmod_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_fmoderror_param_template
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])


		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 1.0])
		else:
			eqnd.execute([ 1.0])


	########################################################
	def test_nan_math_fmod_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_fmod_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_fmoderror_param_template
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])


		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 1.0])
		else:
			eqnd.execute([ 1.0])


	########################################################
	def test_inf_math_fmod_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_fmod_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_fmoderror_param_template
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])


		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 1.0])
		else:
			eqnd.execute([ 1.0])


	########################################################
	def test_ninf_math_fmod_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_fmod_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_fmod_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_fmoderror_param_template
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0])


		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 2.0])
		else:
			eqnd.execute([ 2.0])


	########################################################
	def test_nan_math_fmod_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_fmod_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_fmoderror_param_template
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0])


		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 2.0])
		else:
			eqnd.execute([ 2.0])


	########################################################
	def test_inf_math_fmod_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_fmod_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_fmoderror_param_template
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0])


		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 2.0])
		else:
			eqnd.execute([ 2.0])


	########################################################
	def test_ninf_math_fmod_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.fmod(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_gamma_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [1.0] * 10)
		self.dataok = array.array('d', [1.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_gamma_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.gamma(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_gamma_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.gamma(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_inf_math_gamma_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.gamma(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_gamma_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.gamma(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_ninf_math_gamma_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.gamma(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_gamma_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.gamma(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_hypot_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([-2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_nan_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([-2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_inf_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([-2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2.0])


	########################################################
	def test_ninf_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([-2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_hypot_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_nan_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_inf_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1.0])


	########################################################
	def test_ninf_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ -1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_hypot_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_nan_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_inf_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0.0])


	########################################################
	def test_ninf_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 0.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_hypot_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_nan_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_inf_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1.0])


	########################################################
	def test_ninf_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_hypot_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_nan_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_inf_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2.0])


	########################################################
	def test_ninf_math_hypot_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.hypot(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_ldexp_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([-2])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2])


	########################################################
	def test_nan_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-2))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([-2], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([-2])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2])


	########################################################
	def test_inf_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([-2], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([-2])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([-2])


	########################################################
	def test_ninf_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([-2], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_ldexp_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ -1])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1])


	########################################################
	def test_nan_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ -1])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1])


	########################################################
	def test_inf_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ -1])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ -1])


	########################################################
	def test_ninf_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ -1], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_ldexp_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0])


	########################################################
	def test_nan_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0])


	########################################################
	def test_inf_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 0])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 0])


	########################################################
	def test_ninf_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 0))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 0], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_ldexp_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 1])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1])


	########################################################
	def test_nan_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 1])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1])


	########################################################
	def test_inf_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 1])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 1])


	########################################################
	def test_ninf_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 1], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_ldexp_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 2])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2])


	########################################################
	def test_nan_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 2])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2])


	########################################################
	def test_inf_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_ldexp_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 2])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([ 2])


	########################################################
	def test_ninf_math_ldexp_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.ldexp(x, y)', 'x', ['y'])
		eqnd.execute([ 2], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_lgamma_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [1.0] * 10)
		self.dataok = array.array('d', [1.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_lgamma_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.lgamma(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_lgamma_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.lgamma(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.lgamma(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_lgamma_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.lgamma(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_lgamma_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.lgamma(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.lgamma(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_lgamma_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.lgamma(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_lgamma_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.lgamma(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.lgamma(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_log_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [1.0] * 10)
		self.dataok = array.array('d', [1.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_log_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.log(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_log_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.log(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.log(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_log_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.log(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_log_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.log(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.log(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_log_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.log(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_log_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.log(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_log10_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [1.0] * 10)
		self.dataok = array.array('d', [1.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_log10_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.log10(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_log10_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.log10(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.log10(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_log10_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.log10(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_log10_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.log10(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.log10(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_log10_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.log10(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_log10_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.log10(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_log1p_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [1.0] * 10)
		self.dataok = array.array('d', [1.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_log1p_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.log1p(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_log1p_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.log1p(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.log1p(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_log1p_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.log1p(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_log1p_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.log1p(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.log1p(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_log1p_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.log1p(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_log1p_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.log1p(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_log2_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [1.0] * 10)
		self.dataok = array.array('d', [1.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_log2_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.log2(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_log2_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.log2(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.log2(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_log2_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.log2(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_log2_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.log2(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.log2(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_log2_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.log2(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_log2_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.log2(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_pow_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_pow_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([0.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([0.0])
		else:
			eqnd.execute([0.0])


	########################################################
	def test_nan_math_pow_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([0.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_pow_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([0.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([0.0])
		else:
			eqnd.execute([0.0])


	########################################################
	def test_inf_math_pow_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([0.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_pow_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([0.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([0.0])
		else:
			eqnd.execute([0.0])


	########################################################
	def test_ninf_math_pow_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([0.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_pow_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_pow_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 1.0])
		else:
			eqnd.execute([ 1.0])


	########################################################
	def test_nan_math_pow_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_pow_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 1.0])
		else:
			eqnd.execute([ 1.0])


	########################################################
	def test_inf_math_pow_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_pow_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 1.0])
		else:
			eqnd.execute([ 1.0])


	########################################################
	def test_ninf_math_pow_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 1.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_pow_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_pow_acalcvm(self):
		"""Test acalcvm for data of nan where an error is expected - Array code d.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 2.0])
		else:
			eqnd.execute([ 2.0])


	########################################################
	def test_nan_math_pow_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_pow_acalcvm(self):
		"""Test acalcvm for data of inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 2.0])
		else:
			eqnd.execute([ 2.0])


	########################################################
	def test_inf_math_pow_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_pow_acalcvm(self):
		"""Test acalcvm for data of -inf where an error is expected - Array code d.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([ 2.0])
		else:
			eqnd.execute([ 2.0])


	########################################################
	def test_ninf_math_pow_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.pow(x, y)', 'x', ['y'])
		eqnd.execute([ 2.0], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_radians_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_radians_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.radians(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_radians_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.radians(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.radians(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_radians_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.radians(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_radians_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.radians(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.radians(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_radians_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.radians(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_radians_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.radians(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.radians(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_sin_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_sin_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.sin(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_sin_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.sin(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.sin(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_sin_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.sin(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_sin_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.sin(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_ninf_math_sin_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.sin(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_sin_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.sin(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_sinh_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_sinh_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.sinh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_sinh_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.sinh(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.sinh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_sinh_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.sinh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_sinh_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.sinh(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.sinh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_sinh_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.sinh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_sinh_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.sinh(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.sinh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_sqrt_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_sqrt_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.sqrt(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_sqrt_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.sqrt(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.sqrt(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_sqrt_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.sqrt(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_sqrt_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.sqrt(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.sqrt(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_sqrt_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.sqrt(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_sqrt_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.sqrt(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_tan_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_tan_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.tan(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_tan_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.tan(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.tan(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_tan_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.tan(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_tan_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.tan(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_ninf_math_tan_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.tan(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_tan_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.tan(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_nan_data_math_tanh_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_tanh_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.tanh(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_tanh_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.datanan]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.tanh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_tanh_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.tanh(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_tanh_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.datainf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.tanh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_tanh_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.tanh(x)', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_tanh_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.dataninf]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.tanh(x)', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class acalcvm_nan_data_math_trunc_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_trunc_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.trunc(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_nan_math_trunc_ov_acalcvm(self):
		"""Test acalcvm for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datanan, self.dataout)
		eqnd.comp('math.trunc(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_inf_math_trunc_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.trunc(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_inf_math_trunc_ov_acalcvm(self):
		"""Test acalcvm for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.datainf, self.dataout)
		eqnd.comp('math.trunc(x)', 'x', [])
		eqnd.execute([], disovfl=True)


	########################################################
	def test_ninf_math_trunc_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.trunc(x)', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_ninf_math_trunc_ov_acalcvm(self):
		"""Test acalcvm for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.dataninf, self.dataout)
		eqnd.comp('math.trunc(x)', 'x', [])
		eqnd.execute([], disovfl=True)

##############################################################################

##############################################################################
class acalcvm_arraycheck_b(unittest.TestCase):
	"""Test for VM control data array checks.
	"""
	# Template name: arraycheck_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'b'

		data = array.array('b', [1, 2, 3, 4, 5] * 10)
		dataout = array.array('b', [0]*len(data))

		# Set up the equation ready to execute.
		self.eqnd = arrayfunc.acalc.calc(data, dataout)


	########################################################
	def test_checkvaroffsets_ok_b_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - This should pass - Array code b.
		"""
		# Template name: test_template_arraycheck

		# This should pass.
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		self.eqnd.execute([2, 3])


	########################################################
	def test_checkvaroffsets_first_offset_b_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - Array offset from first variable - Array code b.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		# Modify the variable offset array.
		self.eqnd._varoffsetarray[0] = len(self.eqnd._varoffsetarray) + 1

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm variable array overflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkvaroffsets_second_offset_offset_b_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - Array offset from second variable - Array code b.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		# Modify the variable offset array.
		self.eqnd._varoffsetarray[1] = len(self.eqnd._varoffsetarray) + 1

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm variable array overflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_first_opcode_b_acalcvm(self):
		"""Test acalcvm for checkstackerror - First op code is not a push - Array code b.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify the first op code. The integer and float values should be the
		# same for ths op code, but we won't count on it. 
		if 'b' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['add'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['add'].intval

		self.eqnd._codearray[0] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_unknown_opcode_b_acalcvm(self):
		"""Test acalcvm for checkstackerror - Op code is unknown - Array code b.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify the first op code to something greater than the max value.  
		if 'b' in ('f', 'd'):
			testval = max(arrayfunc.acalc._OpCodesFloat.values()) + 1
		else:
			testval = max(arrayfunc.acalc._OpCodesInt.values()) + 1

		self.eqnd._codearray[1] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm uknown op code.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_stackoverflow_b_acalcvm(self):
		"""Test acalcvm for checkstackerror - Stack overflow - Array code b.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify all the op codes to ones which add to the stack. 
		if 'b' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['pusharray'].floatval
			addval = arrayfunc.acalc._OpCodes['add'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['pusharray'].intval
			addval = arrayfunc.acalc._OpCodes['add'].intval

		# Find the first add opcode.
		addpos = self.eqnd._codearray.index(addval)

		codearraytype = self.eqnd._codearray.typecode
		self.eqnd._codearray[addpos] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_stackunderflow_b_acalcvm(self):
		"""Test acalcvm for checkstackerror - Stack underflow - Array code b.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify all the op codes to ones which add to the stack. 
		if 'b' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['add'].floatval
			pusharrayval = arrayfunc.acalc._OpCodes['pusharray'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['add'].intval
			pusharrayval = arrayfunc.acalc._OpCodes['pusharray'].floatval

		# Find the first pusharray opcode.
		pusharraypos = self.eqnd._codearray.index(pusharrayval)

		codearraytype = self.eqnd._codearray.typecode
		self.eqnd._codearray[pusharraypos] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


##############################################################################

##############################################################################
class acalcvm_arraycheck_B(unittest.TestCase):
	"""Test for VM control data array checks.
	"""
	# Template name: arraycheck_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'

		data = array.array('B', [1, 2, 3, 4, 5] * 10)
		dataout = array.array('B', [0]*len(data))

		# Set up the equation ready to execute.
		self.eqnd = arrayfunc.acalc.calc(data, dataout)


	########################################################
	def test_checkvaroffsets_ok_B_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - This should pass - Array code B.
		"""
		# Template name: test_template_arraycheck

		# This should pass.
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		self.eqnd.execute([2, 3])


	########################################################
	def test_checkvaroffsets_first_offset_B_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - Array offset from first variable - Array code B.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		# Modify the variable offset array.
		self.eqnd._varoffsetarray[0] = len(self.eqnd._varoffsetarray) + 1

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm variable array overflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkvaroffsets_second_offset_offset_B_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - Array offset from second variable - Array code B.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		# Modify the variable offset array.
		self.eqnd._varoffsetarray[1] = len(self.eqnd._varoffsetarray) + 1

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm variable array overflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_first_opcode_B_acalcvm(self):
		"""Test acalcvm for checkstackerror - First op code is not a push - Array code B.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify the first op code. The integer and float values should be the
		# same for ths op code, but we won't count on it. 
		if 'B' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['add'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['add'].intval

		self.eqnd._codearray[0] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_unknown_opcode_B_acalcvm(self):
		"""Test acalcvm for checkstackerror - Op code is unknown - Array code B.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify the first op code to something greater than the max value.  
		if 'B' in ('f', 'd'):
			testval = max(arrayfunc.acalc._OpCodesFloat.values()) + 1
		else:
			testval = max(arrayfunc.acalc._OpCodesInt.values()) + 1

		self.eqnd._codearray[1] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm uknown op code.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_stackoverflow_B_acalcvm(self):
		"""Test acalcvm for checkstackerror - Stack overflow - Array code B.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify all the op codes to ones which add to the stack. 
		if 'B' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['pusharray'].floatval
			addval = arrayfunc.acalc._OpCodes['add'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['pusharray'].intval
			addval = arrayfunc.acalc._OpCodes['add'].intval

		# Find the first add opcode.
		addpos = self.eqnd._codearray.index(addval)

		codearraytype = self.eqnd._codearray.typecode
		self.eqnd._codearray[addpos] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_stackunderflow_B_acalcvm(self):
		"""Test acalcvm for checkstackerror - Stack underflow - Array code B.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify all the op codes to ones which add to the stack. 
		if 'B' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['add'].floatval
			pusharrayval = arrayfunc.acalc._OpCodes['pusharray'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['add'].intval
			pusharrayval = arrayfunc.acalc._OpCodes['pusharray'].floatval

		# Find the first pusharray opcode.
		pusharraypos = self.eqnd._codearray.index(pusharrayval)

		codearraytype = self.eqnd._codearray.typecode
		self.eqnd._codearray[pusharraypos] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


##############################################################################

##############################################################################
class acalcvm_arraycheck_h(unittest.TestCase):
	"""Test for VM control data array checks.
	"""
	# Template name: arraycheck_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'h'

		data = array.array('h', [1, 2, 3, 4, 5] * 10)
		dataout = array.array('h', [0]*len(data))

		# Set up the equation ready to execute.
		self.eqnd = arrayfunc.acalc.calc(data, dataout)


	########################################################
	def test_checkvaroffsets_ok_h_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - This should pass - Array code h.
		"""
		# Template name: test_template_arraycheck

		# This should pass.
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		self.eqnd.execute([2, 3])


	########################################################
	def test_checkvaroffsets_first_offset_h_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - Array offset from first variable - Array code h.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		# Modify the variable offset array.
		self.eqnd._varoffsetarray[0] = len(self.eqnd._varoffsetarray) + 1

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm variable array overflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkvaroffsets_second_offset_offset_h_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - Array offset from second variable - Array code h.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		# Modify the variable offset array.
		self.eqnd._varoffsetarray[1] = len(self.eqnd._varoffsetarray) + 1

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm variable array overflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_first_opcode_h_acalcvm(self):
		"""Test acalcvm for checkstackerror - First op code is not a push - Array code h.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify the first op code. The integer and float values should be the
		# same for ths op code, but we won't count on it. 
		if 'h' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['add'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['add'].intval

		self.eqnd._codearray[0] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_unknown_opcode_h_acalcvm(self):
		"""Test acalcvm for checkstackerror - Op code is unknown - Array code h.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify the first op code to something greater than the max value.  
		if 'h' in ('f', 'd'):
			testval = max(arrayfunc.acalc._OpCodesFloat.values()) + 1
		else:
			testval = max(arrayfunc.acalc._OpCodesInt.values()) + 1

		self.eqnd._codearray[1] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm uknown op code.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_stackoverflow_h_acalcvm(self):
		"""Test acalcvm for checkstackerror - Stack overflow - Array code h.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify all the op codes to ones which add to the stack. 
		if 'h' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['pusharray'].floatval
			addval = arrayfunc.acalc._OpCodes['add'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['pusharray'].intval
			addval = arrayfunc.acalc._OpCodes['add'].intval

		# Find the first add opcode.
		addpos = self.eqnd._codearray.index(addval)

		codearraytype = self.eqnd._codearray.typecode
		self.eqnd._codearray[addpos] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_stackunderflow_h_acalcvm(self):
		"""Test acalcvm for checkstackerror - Stack underflow - Array code h.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify all the op codes to ones which add to the stack. 
		if 'h' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['add'].floatval
			pusharrayval = arrayfunc.acalc._OpCodes['pusharray'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['add'].intval
			pusharrayval = arrayfunc.acalc._OpCodes['pusharray'].floatval

		# Find the first pusharray opcode.
		pusharraypos = self.eqnd._codearray.index(pusharrayval)

		codearraytype = self.eqnd._codearray.typecode
		self.eqnd._codearray[pusharraypos] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


##############################################################################

##############################################################################
class acalcvm_arraycheck_H(unittest.TestCase):
	"""Test for VM control data array checks.
	"""
	# Template name: arraycheck_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'H'

		data = array.array('H', [1, 2, 3, 4, 5] * 10)
		dataout = array.array('H', [0]*len(data))

		# Set up the equation ready to execute.
		self.eqnd = arrayfunc.acalc.calc(data, dataout)


	########################################################
	def test_checkvaroffsets_ok_H_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - This should pass - Array code H.
		"""
		# Template name: test_template_arraycheck

		# This should pass.
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		self.eqnd.execute([2, 3])


	########################################################
	def test_checkvaroffsets_first_offset_H_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - Array offset from first variable - Array code H.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		# Modify the variable offset array.
		self.eqnd._varoffsetarray[0] = len(self.eqnd._varoffsetarray) + 1

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm variable array overflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkvaroffsets_second_offset_offset_H_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - Array offset from second variable - Array code H.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		# Modify the variable offset array.
		self.eqnd._varoffsetarray[1] = len(self.eqnd._varoffsetarray) + 1

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm variable array overflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_first_opcode_H_acalcvm(self):
		"""Test acalcvm for checkstackerror - First op code is not a push - Array code H.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify the first op code. The integer and float values should be the
		# same for ths op code, but we won't count on it. 
		if 'H' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['add'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['add'].intval

		self.eqnd._codearray[0] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_unknown_opcode_H_acalcvm(self):
		"""Test acalcvm for checkstackerror - Op code is unknown - Array code H.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify the first op code to something greater than the max value.  
		if 'H' in ('f', 'd'):
			testval = max(arrayfunc.acalc._OpCodesFloat.values()) + 1
		else:
			testval = max(arrayfunc.acalc._OpCodesInt.values()) + 1

		self.eqnd._codearray[1] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm uknown op code.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_stackoverflow_H_acalcvm(self):
		"""Test acalcvm for checkstackerror - Stack overflow - Array code H.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify all the op codes to ones which add to the stack. 
		if 'H' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['pusharray'].floatval
			addval = arrayfunc.acalc._OpCodes['add'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['pusharray'].intval
			addval = arrayfunc.acalc._OpCodes['add'].intval

		# Find the first add opcode.
		addpos = self.eqnd._codearray.index(addval)

		codearraytype = self.eqnd._codearray.typecode
		self.eqnd._codearray[addpos] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_stackunderflow_H_acalcvm(self):
		"""Test acalcvm for checkstackerror - Stack underflow - Array code H.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify all the op codes to ones which add to the stack. 
		if 'H' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['add'].floatval
			pusharrayval = arrayfunc.acalc._OpCodes['pusharray'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['add'].intval
			pusharrayval = arrayfunc.acalc._OpCodes['pusharray'].floatval

		# Find the first pusharray opcode.
		pusharraypos = self.eqnd._codearray.index(pusharrayval)

		codearraytype = self.eqnd._codearray.typecode
		self.eqnd._codearray[pusharraypos] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


##############################################################################

##############################################################################
class acalcvm_arraycheck_i(unittest.TestCase):
	"""Test for VM control data array checks.
	"""
	# Template name: arraycheck_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'i'

		data = array.array('i', [1, 2, 3, 4, 5] * 10)
		dataout = array.array('i', [0]*len(data))

		# Set up the equation ready to execute.
		self.eqnd = arrayfunc.acalc.calc(data, dataout)


	########################################################
	def test_checkvaroffsets_ok_i_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - This should pass - Array code i.
		"""
		# Template name: test_template_arraycheck

		# This should pass.
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		self.eqnd.execute([2, 3])


	########################################################
	def test_checkvaroffsets_first_offset_i_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - Array offset from first variable - Array code i.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		# Modify the variable offset array.
		self.eqnd._varoffsetarray[0] = len(self.eqnd._varoffsetarray) + 1

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm variable array overflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkvaroffsets_second_offset_offset_i_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - Array offset from second variable - Array code i.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		# Modify the variable offset array.
		self.eqnd._varoffsetarray[1] = len(self.eqnd._varoffsetarray) + 1

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm variable array overflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_first_opcode_i_acalcvm(self):
		"""Test acalcvm for checkstackerror - First op code is not a push - Array code i.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify the first op code. The integer and float values should be the
		# same for ths op code, but we won't count on it. 
		if 'i' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['add'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['add'].intval

		self.eqnd._codearray[0] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_unknown_opcode_i_acalcvm(self):
		"""Test acalcvm for checkstackerror - Op code is unknown - Array code i.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify the first op code to something greater than the max value.  
		if 'i' in ('f', 'd'):
			testval = max(arrayfunc.acalc._OpCodesFloat.values()) + 1
		else:
			testval = max(arrayfunc.acalc._OpCodesInt.values()) + 1

		self.eqnd._codearray[1] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm uknown op code.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_stackoverflow_i_acalcvm(self):
		"""Test acalcvm for checkstackerror - Stack overflow - Array code i.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify all the op codes to ones which add to the stack. 
		if 'i' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['pusharray'].floatval
			addval = arrayfunc.acalc._OpCodes['add'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['pusharray'].intval
			addval = arrayfunc.acalc._OpCodes['add'].intval

		# Find the first add opcode.
		addpos = self.eqnd._codearray.index(addval)

		codearraytype = self.eqnd._codearray.typecode
		self.eqnd._codearray[addpos] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_stackunderflow_i_acalcvm(self):
		"""Test acalcvm for checkstackerror - Stack underflow - Array code i.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify all the op codes to ones which add to the stack. 
		if 'i' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['add'].floatval
			pusharrayval = arrayfunc.acalc._OpCodes['pusharray'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['add'].intval
			pusharrayval = arrayfunc.acalc._OpCodes['pusharray'].floatval

		# Find the first pusharray opcode.
		pusharraypos = self.eqnd._codearray.index(pusharrayval)

		codearraytype = self.eqnd._codearray.typecode
		self.eqnd._codearray[pusharraypos] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


##############################################################################

##############################################################################
class acalcvm_arraycheck_I(unittest.TestCase):
	"""Test for VM control data array checks.
	"""
	# Template name: arraycheck_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'I'

		data = array.array('I', [1, 2, 3, 4, 5] * 10)
		dataout = array.array('I', [0]*len(data))

		# Set up the equation ready to execute.
		self.eqnd = arrayfunc.acalc.calc(data, dataout)


	########################################################
	def test_checkvaroffsets_ok_I_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - This should pass - Array code I.
		"""
		# Template name: test_template_arraycheck

		# This should pass.
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		self.eqnd.execute([2, 3])


	########################################################
	def test_checkvaroffsets_first_offset_I_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - Array offset from first variable - Array code I.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		# Modify the variable offset array.
		self.eqnd._varoffsetarray[0] = len(self.eqnd._varoffsetarray) + 1

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm variable array overflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkvaroffsets_second_offset_offset_I_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - Array offset from second variable - Array code I.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		# Modify the variable offset array.
		self.eqnd._varoffsetarray[1] = len(self.eqnd._varoffsetarray) + 1

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm variable array overflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_first_opcode_I_acalcvm(self):
		"""Test acalcvm for checkstackerror - First op code is not a push - Array code I.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify the first op code. The integer and float values should be the
		# same for ths op code, but we won't count on it. 
		if 'I' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['add'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['add'].intval

		self.eqnd._codearray[0] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_unknown_opcode_I_acalcvm(self):
		"""Test acalcvm for checkstackerror - Op code is unknown - Array code I.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify the first op code to something greater than the max value.  
		if 'I' in ('f', 'd'):
			testval = max(arrayfunc.acalc._OpCodesFloat.values()) + 1
		else:
			testval = max(arrayfunc.acalc._OpCodesInt.values()) + 1

		self.eqnd._codearray[1] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm uknown op code.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_stackoverflow_I_acalcvm(self):
		"""Test acalcvm for checkstackerror - Stack overflow - Array code I.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify all the op codes to ones which add to the stack. 
		if 'I' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['pusharray'].floatval
			addval = arrayfunc.acalc._OpCodes['add'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['pusharray'].intval
			addval = arrayfunc.acalc._OpCodes['add'].intval

		# Find the first add opcode.
		addpos = self.eqnd._codearray.index(addval)

		codearraytype = self.eqnd._codearray.typecode
		self.eqnd._codearray[addpos] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_stackunderflow_I_acalcvm(self):
		"""Test acalcvm for checkstackerror - Stack underflow - Array code I.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify all the op codes to ones which add to the stack. 
		if 'I' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['add'].floatval
			pusharrayval = arrayfunc.acalc._OpCodes['pusharray'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['add'].intval
			pusharrayval = arrayfunc.acalc._OpCodes['pusharray'].floatval

		# Find the first pusharray opcode.
		pusharraypos = self.eqnd._codearray.index(pusharrayval)

		codearraytype = self.eqnd._codearray.typecode
		self.eqnd._codearray[pusharraypos] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


##############################################################################

##############################################################################
class acalcvm_arraycheck_l(unittest.TestCase):
	"""Test for VM control data array checks.
	"""
	# Template name: arraycheck_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'l'

		data = array.array('l', [1, 2, 3, 4, 5] * 10)
		dataout = array.array('l', [0]*len(data))

		# Set up the equation ready to execute.
		self.eqnd = arrayfunc.acalc.calc(data, dataout)


	########################################################
	def test_checkvaroffsets_ok_l_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - This should pass - Array code l.
		"""
		# Template name: test_template_arraycheck

		# This should pass.
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		self.eqnd.execute([2, 3])


	########################################################
	def test_checkvaroffsets_first_offset_l_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - Array offset from first variable - Array code l.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		# Modify the variable offset array.
		self.eqnd._varoffsetarray[0] = len(self.eqnd._varoffsetarray) + 1

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm variable array overflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkvaroffsets_second_offset_offset_l_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - Array offset from second variable - Array code l.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		# Modify the variable offset array.
		self.eqnd._varoffsetarray[1] = len(self.eqnd._varoffsetarray) + 1

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm variable array overflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_first_opcode_l_acalcvm(self):
		"""Test acalcvm for checkstackerror - First op code is not a push - Array code l.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify the first op code. The integer and float values should be the
		# same for ths op code, but we won't count on it. 
		if 'l' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['add'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['add'].intval

		self.eqnd._codearray[0] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_unknown_opcode_l_acalcvm(self):
		"""Test acalcvm for checkstackerror - Op code is unknown - Array code l.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify the first op code to something greater than the max value.  
		if 'l' in ('f', 'd'):
			testval = max(arrayfunc.acalc._OpCodesFloat.values()) + 1
		else:
			testval = max(arrayfunc.acalc._OpCodesInt.values()) + 1

		self.eqnd._codearray[1] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm uknown op code.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_stackoverflow_l_acalcvm(self):
		"""Test acalcvm for checkstackerror - Stack overflow - Array code l.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify all the op codes to ones which add to the stack. 
		if 'l' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['pusharray'].floatval
			addval = arrayfunc.acalc._OpCodes['add'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['pusharray'].intval
			addval = arrayfunc.acalc._OpCodes['add'].intval

		# Find the first add opcode.
		addpos = self.eqnd._codearray.index(addval)

		codearraytype = self.eqnd._codearray.typecode
		self.eqnd._codearray[addpos] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_stackunderflow_l_acalcvm(self):
		"""Test acalcvm for checkstackerror - Stack underflow - Array code l.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify all the op codes to ones which add to the stack. 
		if 'l' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['add'].floatval
			pusharrayval = arrayfunc.acalc._OpCodes['pusharray'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['add'].intval
			pusharrayval = arrayfunc.acalc._OpCodes['pusharray'].floatval

		# Find the first pusharray opcode.
		pusharraypos = self.eqnd._codearray.index(pusharrayval)

		codearraytype = self.eqnd._codearray.typecode
		self.eqnd._codearray[pusharraypos] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


##############################################################################

##############################################################################
class acalcvm_arraycheck_L(unittest.TestCase):
	"""Test for VM control data array checks.
	"""
	# Template name: arraycheck_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'L'

		data = array.array('L', [1, 2, 3, 4, 5] * 10)
		dataout = array.array('L', [0]*len(data))

		# Set up the equation ready to execute.
		self.eqnd = arrayfunc.acalc.calc(data, dataout)


	########################################################
	def test_checkvaroffsets_ok_L_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - This should pass - Array code L.
		"""
		# Template name: test_template_arraycheck

		# This should pass.
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		self.eqnd.execute([2, 3])


	########################################################
	def test_checkvaroffsets_first_offset_L_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - Array offset from first variable - Array code L.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		# Modify the variable offset array.
		self.eqnd._varoffsetarray[0] = len(self.eqnd._varoffsetarray) + 1

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm variable array overflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkvaroffsets_second_offset_offset_L_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - Array offset from second variable - Array code L.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		# Modify the variable offset array.
		self.eqnd._varoffsetarray[1] = len(self.eqnd._varoffsetarray) + 1

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm variable array overflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_first_opcode_L_acalcvm(self):
		"""Test acalcvm for checkstackerror - First op code is not a push - Array code L.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify the first op code. The integer and float values should be the
		# same for ths op code, but we won't count on it. 
		if 'L' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['add'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['add'].intval

		self.eqnd._codearray[0] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_unknown_opcode_L_acalcvm(self):
		"""Test acalcvm for checkstackerror - Op code is unknown - Array code L.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify the first op code to something greater than the max value.  
		if 'L' in ('f', 'd'):
			testval = max(arrayfunc.acalc._OpCodesFloat.values()) + 1
		else:
			testval = max(arrayfunc.acalc._OpCodesInt.values()) + 1

		self.eqnd._codearray[1] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm uknown op code.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_stackoverflow_L_acalcvm(self):
		"""Test acalcvm for checkstackerror - Stack overflow - Array code L.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify all the op codes to ones which add to the stack. 
		if 'L' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['pusharray'].floatval
			addval = arrayfunc.acalc._OpCodes['add'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['pusharray'].intval
			addval = arrayfunc.acalc._OpCodes['add'].intval

		# Find the first add opcode.
		addpos = self.eqnd._codearray.index(addval)

		codearraytype = self.eqnd._codearray.typecode
		self.eqnd._codearray[addpos] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_stackunderflow_L_acalcvm(self):
		"""Test acalcvm for checkstackerror - Stack underflow - Array code L.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify all the op codes to ones which add to the stack. 
		if 'L' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['add'].floatval
			pusharrayval = arrayfunc.acalc._OpCodes['pusharray'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['add'].intval
			pusharrayval = arrayfunc.acalc._OpCodes['pusharray'].floatval

		# Find the first pusharray opcode.
		pusharraypos = self.eqnd._codearray.index(pusharrayval)

		codearraytype = self.eqnd._codearray.typecode
		self.eqnd._codearray[pusharraypos] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


##############################################################################

##############################################################################
class acalcvm_arraycheck_q(unittest.TestCase):
	"""Test for VM control data array checks.
	"""
	# Template name: arraycheck_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'q'

		data = array.array('q', [1, 2, 3, 4, 5] * 10)
		dataout = array.array('q', [0]*len(data))

		# Set up the equation ready to execute.
		self.eqnd = arrayfunc.acalc.calc(data, dataout)


	########################################################
	def test_checkvaroffsets_ok_q_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - This should pass - Array code q.
		"""
		# Template name: test_template_arraycheck

		# This should pass.
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		self.eqnd.execute([2, 3])


	########################################################
	def test_checkvaroffsets_first_offset_q_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - Array offset from first variable - Array code q.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		# Modify the variable offset array.
		self.eqnd._varoffsetarray[0] = len(self.eqnd._varoffsetarray) + 1

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm variable array overflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkvaroffsets_second_offset_offset_q_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - Array offset from second variable - Array code q.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		# Modify the variable offset array.
		self.eqnd._varoffsetarray[1] = len(self.eqnd._varoffsetarray) + 1

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm variable array overflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_first_opcode_q_acalcvm(self):
		"""Test acalcvm for checkstackerror - First op code is not a push - Array code q.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify the first op code. The integer and float values should be the
		# same for ths op code, but we won't count on it. 
		if 'q' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['add'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['add'].intval

		self.eqnd._codearray[0] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_unknown_opcode_q_acalcvm(self):
		"""Test acalcvm for checkstackerror - Op code is unknown - Array code q.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify the first op code to something greater than the max value.  
		if 'q' in ('f', 'd'):
			testval = max(arrayfunc.acalc._OpCodesFloat.values()) + 1
		else:
			testval = max(arrayfunc.acalc._OpCodesInt.values()) + 1

		self.eqnd._codearray[1] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm uknown op code.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_stackoverflow_q_acalcvm(self):
		"""Test acalcvm for checkstackerror - Stack overflow - Array code q.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify all the op codes to ones which add to the stack. 
		if 'q' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['pusharray'].floatval
			addval = arrayfunc.acalc._OpCodes['add'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['pusharray'].intval
			addval = arrayfunc.acalc._OpCodes['add'].intval

		# Find the first add opcode.
		addpos = self.eqnd._codearray.index(addval)

		codearraytype = self.eqnd._codearray.typecode
		self.eqnd._codearray[addpos] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_stackunderflow_q_acalcvm(self):
		"""Test acalcvm for checkstackerror - Stack underflow - Array code q.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify all the op codes to ones which add to the stack. 
		if 'q' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['add'].floatval
			pusharrayval = arrayfunc.acalc._OpCodes['pusharray'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['add'].intval
			pusharrayval = arrayfunc.acalc._OpCodes['pusharray'].floatval

		# Find the first pusharray opcode.
		pusharraypos = self.eqnd._codearray.index(pusharrayval)

		codearraytype = self.eqnd._codearray.typecode
		self.eqnd._codearray[pusharraypos] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


##############################################################################

##############################################################################
class acalcvm_arraycheck_Q(unittest.TestCase):
	"""Test for VM control data array checks.
	"""
	# Template name: arraycheck_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'Q'

		data = array.array('Q', [1, 2, 3, 4, 5] * 10)
		dataout = array.array('Q', [0]*len(data))

		# Set up the equation ready to execute.
		self.eqnd = arrayfunc.acalc.calc(data, dataout)


	########################################################
	def test_checkvaroffsets_ok_Q_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - This should pass - Array code Q.
		"""
		# Template name: test_template_arraycheck

		# This should pass.
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		self.eqnd.execute([2, 3])


	########################################################
	def test_checkvaroffsets_first_offset_Q_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - Array offset from first variable - Array code Q.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		# Modify the variable offset array.
		self.eqnd._varoffsetarray[0] = len(self.eqnd._varoffsetarray) + 1

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm variable array overflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkvaroffsets_second_offset_offset_Q_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - Array offset from second variable - Array code Q.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		# Modify the variable offset array.
		self.eqnd._varoffsetarray[1] = len(self.eqnd._varoffsetarray) + 1

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm variable array overflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_first_opcode_Q_acalcvm(self):
		"""Test acalcvm for checkstackerror - First op code is not a push - Array code Q.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify the first op code. The integer and float values should be the
		# same for ths op code, but we won't count on it. 
		if 'Q' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['add'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['add'].intval

		self.eqnd._codearray[0] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_unknown_opcode_Q_acalcvm(self):
		"""Test acalcvm for checkstackerror - Op code is unknown - Array code Q.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify the first op code to something greater than the max value.  
		if 'Q' in ('f', 'd'):
			testval = max(arrayfunc.acalc._OpCodesFloat.values()) + 1
		else:
			testval = max(arrayfunc.acalc._OpCodesInt.values()) + 1

		self.eqnd._codearray[1] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm uknown op code.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_stackoverflow_Q_acalcvm(self):
		"""Test acalcvm for checkstackerror - Stack overflow - Array code Q.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify all the op codes to ones which add to the stack. 
		if 'Q' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['pusharray'].floatval
			addval = arrayfunc.acalc._OpCodes['add'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['pusharray'].intval
			addval = arrayfunc.acalc._OpCodes['add'].intval

		# Find the first add opcode.
		addpos = self.eqnd._codearray.index(addval)

		codearraytype = self.eqnd._codearray.typecode
		self.eqnd._codearray[addpos] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_stackunderflow_Q_acalcvm(self):
		"""Test acalcvm for checkstackerror - Stack underflow - Array code Q.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify all the op codes to ones which add to the stack. 
		if 'Q' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['add'].floatval
			pusharrayval = arrayfunc.acalc._OpCodes['pusharray'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['add'].intval
			pusharrayval = arrayfunc.acalc._OpCodes['pusharray'].floatval

		# Find the first pusharray opcode.
		pusharraypos = self.eqnd._codearray.index(pusharrayval)

		codearraytype = self.eqnd._codearray.typecode
		self.eqnd._codearray[pusharraypos] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


##############################################################################

##############################################################################
class acalcvm_arraycheck_f(unittest.TestCase):
	"""Test for VM control data array checks.
	"""
	# Template name: arraycheck_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'f'

		data = array.array('f', [1, 2, 3, 4, 5] * 10)
		dataout = array.array('f', [0]*len(data))

		# Set up the equation ready to execute.
		self.eqnd = arrayfunc.acalc.calc(data, dataout)


	########################################################
	def test_checkvaroffsets_ok_f_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - This should pass - Array code f.
		"""
		# Template name: test_template_arraycheck

		# This should pass.
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		self.eqnd.execute([2, 3])


	########################################################
	def test_checkvaroffsets_first_offset_f_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - Array offset from first variable - Array code f.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		# Modify the variable offset array.
		self.eqnd._varoffsetarray[0] = len(self.eqnd._varoffsetarray) + 1

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm variable array overflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkvaroffsets_second_offset_offset_f_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - Array offset from second variable - Array code f.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		# Modify the variable offset array.
		self.eqnd._varoffsetarray[1] = len(self.eqnd._varoffsetarray) + 1

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm variable array overflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_first_opcode_f_acalcvm(self):
		"""Test acalcvm for checkstackerror - First op code is not a push - Array code f.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify the first op code. The integer and float values should be the
		# same for ths op code, but we won't count on it. 
		if 'f' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['add'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['add'].intval

		self.eqnd._codearray[0] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_unknown_opcode_f_acalcvm(self):
		"""Test acalcvm for checkstackerror - Op code is unknown - Array code f.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify the first op code to something greater than the max value.  
		if 'f' in ('f', 'd'):
			testval = max(arrayfunc.acalc._OpCodesFloat.values()) + 1
		else:
			testval = max(arrayfunc.acalc._OpCodesInt.values()) + 1

		self.eqnd._codearray[1] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm uknown op code.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_stackoverflow_f_acalcvm(self):
		"""Test acalcvm for checkstackerror - Stack overflow - Array code f.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify all the op codes to ones which add to the stack. 
		if 'f' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['pusharray'].floatval
			addval = arrayfunc.acalc._OpCodes['add'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['pusharray'].intval
			addval = arrayfunc.acalc._OpCodes['add'].intval

		# Find the first add opcode.
		addpos = self.eqnd._codearray.index(addval)

		codearraytype = self.eqnd._codearray.typecode
		self.eqnd._codearray[addpos] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_stackunderflow_f_acalcvm(self):
		"""Test acalcvm for checkstackerror - Stack underflow - Array code f.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify all the op codes to ones which add to the stack. 
		if 'f' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['add'].floatval
			pusharrayval = arrayfunc.acalc._OpCodes['pusharray'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['add'].intval
			pusharrayval = arrayfunc.acalc._OpCodes['pusharray'].floatval

		# Find the first pusharray opcode.
		pusharraypos = self.eqnd._codearray.index(pusharrayval)

		codearraytype = self.eqnd._codearray.typecode
		self.eqnd._codearray[pusharraypos] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


##############################################################################

##############################################################################
class acalcvm_arraycheck_d(unittest.TestCase):
	"""Test for VM control data array checks.
	"""
	# Template name: arraycheck_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'd'

		data = array.array('d', [1, 2, 3, 4, 5] * 10)
		dataout = array.array('d', [0]*len(data))

		# Set up the equation ready to execute.
		self.eqnd = arrayfunc.acalc.calc(data, dataout)


	########################################################
	def test_checkvaroffsets_ok_d_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - This should pass - Array code d.
		"""
		# Template name: test_template_arraycheck

		# This should pass.
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		self.eqnd.execute([2, 3])


	########################################################
	def test_checkvaroffsets_first_offset_d_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - Array offset from first variable - Array code d.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		# Modify the variable offset array.
		self.eqnd._varoffsetarray[0] = len(self.eqnd._varoffsetarray) + 1

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm variable array overflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkvaroffsets_second_offset_offset_d_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - Array offset from second variable - Array code d.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		# Modify the variable offset array.
		self.eqnd._varoffsetarray[1] = len(self.eqnd._varoffsetarray) + 1

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm variable array overflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_first_opcode_d_acalcvm(self):
		"""Test acalcvm for checkstackerror - First op code is not a push - Array code d.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify the first op code. The integer and float values should be the
		# same for ths op code, but we won't count on it. 
		if 'd' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['add'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['add'].intval

		self.eqnd._codearray[0] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_unknown_opcode_d_acalcvm(self):
		"""Test acalcvm for checkstackerror - Op code is unknown - Array code d.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify the first op code to something greater than the max value.  
		if 'd' in ('f', 'd'):
			testval = max(arrayfunc.acalc._OpCodesFloat.values()) + 1
		else:
			testval = max(arrayfunc.acalc._OpCodesInt.values()) + 1

		self.eqnd._codearray[1] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm uknown op code.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_stackoverflow_d_acalcvm(self):
		"""Test acalcvm for checkstackerror - Stack overflow - Array code d.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify all the op codes to ones which add to the stack. 
		if 'd' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['pusharray'].floatval
			addval = arrayfunc.acalc._OpCodes['add'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['pusharray'].intval
			addval = arrayfunc.acalc._OpCodes['add'].intval

		# Find the first add opcode.
		addpos = self.eqnd._codearray.index(addval)

		codearraytype = self.eqnd._codearray.typecode
		self.eqnd._codearray[addpos] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_stackunderflow_d_acalcvm(self):
		"""Test acalcvm for checkstackerror - Stack underflow - Array code d.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify all the op codes to ones which add to the stack. 
		if 'd' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['add'].floatval
			pusharrayval = arrayfunc.acalc._OpCodes['pusharray'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['add'].intval
			pusharrayval = arrayfunc.acalc._OpCodes['pusharray'].floatval

		# Find the first pusharray opcode.
		pusharraypos = self.eqnd._codearray.index(pusharrayval)

		codearraytype = self.eqnd._codearray.typecode
		self.eqnd._codearray[pusharraypos] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


##############################################################################

##############################################################################
class acalcvm_arraycheck_bytes(unittest.TestCase):
	"""Test for VM control data array checks.
	"""
	# Template name: arraycheck_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'

		data = array.array('B', [1, 2, 3, 4, 5] * 10)
		dataout = array.array('B', [0]*len(data))

		# Set up the equation ready to execute.
		self.eqnd = arrayfunc.acalc.calc(data, dataout)


	########################################################
	def test_checkvaroffsets_ok_bytes_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - This should pass - Array code bytes.
		"""
		# Template name: test_template_arraycheck

		# This should pass.
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		self.eqnd.execute([2, 3])


	########################################################
	def test_checkvaroffsets_first_offset_bytes_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - Array offset from first variable - Array code bytes.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		# Modify the variable offset array.
		self.eqnd._varoffsetarray[0] = len(self.eqnd._varoffsetarray) + 1

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm variable array overflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkvaroffsets_second_offset_offset_bytes_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - Array offset from second variable - Array code bytes.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		# Modify the variable offset array.
		self.eqnd._varoffsetarray[1] = len(self.eqnd._varoffsetarray) + 1

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm variable array overflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_first_opcode_bytes_acalcvm(self):
		"""Test acalcvm for checkstackerror - First op code is not a push - Array code bytes.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify the first op code. The integer and float values should be the
		# same for ths op code, but we won't count on it. 
		if 'bytes' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['add'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['add'].intval

		self.eqnd._codearray[0] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_unknown_opcode_bytes_acalcvm(self):
		"""Test acalcvm for checkstackerror - Op code is unknown - Array code bytes.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify the first op code to something greater than the max value.  
		if 'bytes' in ('f', 'd'):
			testval = max(arrayfunc.acalc._OpCodesFloat.values()) + 1
		else:
			testval = max(arrayfunc.acalc._OpCodesInt.values()) + 1

		self.eqnd._codearray[1] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm uknown op code.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_stackoverflow_bytes_acalcvm(self):
		"""Test acalcvm for checkstackerror - Stack overflow - Array code bytes.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify all the op codes to ones which add to the stack. 
		if 'bytes' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['pusharray'].floatval
			addval = arrayfunc.acalc._OpCodes['add'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['pusharray'].intval
			addval = arrayfunc.acalc._OpCodes['add'].intval

		# Find the first add opcode.
		addpos = self.eqnd._codearray.index(addval)

		codearraytype = self.eqnd._codearray.typecode
		self.eqnd._codearray[addpos] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_stackunderflow_bytes_acalcvm(self):
		"""Test acalcvm for checkstackerror - Stack underflow - Array code bytes.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify all the op codes to ones which add to the stack. 
		if 'bytes' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['add'].floatval
			pusharrayval = arrayfunc.acalc._OpCodes['pusharray'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['add'].intval
			pusharrayval = arrayfunc.acalc._OpCodes['pusharray'].floatval

		# Find the first pusharray opcode.
		pusharraypos = self.eqnd._codearray.index(pusharrayval)

		codearraytype = self.eqnd._codearray.typecode
		self.eqnd._codearray[pusharraypos] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


##############################################################################

##############################################################################
class acalcvm_mathconst_f(unittest.TestCase):
	"""Test math constants.
	"""
	# Template name: mathconst_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.

		self.data = array.array('f', [1, 2, 3, 4, 5] * 10)
		self.dataout = array.array('f', [0]*len(self.data))

		# Set up the equation ready to execute.
		self.eqnd = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_math_pi_f_acalcvm(self):
		"""Test acalcvm for math constants - math.pi - Array code f.
		"""
		self.eqnd.comp('x + math.pi', 'x', [])
		self.eqnd.execute([])

		expected = [x + math.pi for x in self.data]

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
			self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_math_e_f_acalcvm(self):
		"""Test acalcvm for math constants - math.e - Array code f.
		"""
		self.eqnd.comp('x + math.e', 'x', [])
		self.eqnd.execute([])

		expected = [x + math.e for x in self.data]

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
			self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################


##############################################################################
class acalcvm_mathconst_d(unittest.TestCase):
	"""Test math constants.
	"""
	# Template name: mathconst_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.

		self.data = array.array('d', [1, 2, 3, 4, 5] * 10)
		self.dataout = array.array('d', [0]*len(self.data))

		# Set up the equation ready to execute.
		self.eqnd = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_math_pi_d_acalcvm(self):
		"""Test acalcvm for math constants - math.pi - Array code d.
		"""
		self.eqnd.comp('x + math.pi', 'x', [])
		self.eqnd.execute([])

		expected = [x + math.pi for x in self.data]

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
			self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_math_e_d_acalcvm(self):
		"""Test acalcvm for math constants - math.e - Array code d.
		"""
		self.eqnd.comp('x + math.e', 'x', [])
		self.eqnd.execute([])

		expected = [x + math.e for x in self.data]

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
			self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################


##############################################################################
if __name__ == '__main__':

	# Check to see if the log file option has been selected. This is an option
	# which we have added in order to decide where to output the results.
	if '-l' in sys.argv:
		# Remove the option from the argument list so that "unittest" does 
		# not complain about unknown options.
		sys.argv.remove('-l')

		with open('arrayfunc_unittest.txt', 'a') as f:
			f.write('

')
			f.write('acalcvm

')
			trun = unittest.TextTestRunner(f)
			unittest.main(testRunner=trun)
	else:
		unittest.main()

##############################################################################
