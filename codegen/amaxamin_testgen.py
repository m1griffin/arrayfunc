#!/usr/bin/env python3
##############################################################################
# Project:  arrayfunc
# Purpose:  Generate the unit tests for amax and amin.
# Language: Python 3.6
# Date:     13-May-2014
#
###############################################################################
#
#   Copyright 2014 - 2019    Michael Griffin    <m12.griffin@gmail.com>
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
##############################################################################


# ==============================================================================
import copy
import itertools

import codegen_common

# ==============================================================================

# ==============================================================================

# The basic template for testing each array type for operator function.
op_template_general = '''

##############################################################################
class %(funclabel)s_general_%(arrayevenodd)s_arraysize_%(simdpresent)s_simd_%(typecode)s(unittest.TestCase):
	"""Test %(funclabel)s for basic general function operation.
	op_template_general
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""

		# We use a template to generate this code, so the following
		# compare is inserted into the template to generate code which
		# spills over past the SIMD handler.
		if '%(arrayevenodd)s' == 'odd':
			arrayextension = 5
		else:
			arrayextension = 0

		arraylength = 96 + arrayextension


		MaxVal = arrayfunc.arraylimits.%(typecode)s_max
		MinVal = arrayfunc.arraylimits.%(typecode)s_min


		# This is generated by a common template, so we need to make 
		# sure that in cases where we are using floating point values 
		# we don't pass floating point values for range().
		# Plus, double precision calcuations will overflow when calculating 
		# the step value unless we convert to integer first. Python
		# integers have no upper limit, and so will not overflow.
		MaxInt = int(MaxVal)
		MinInt = int(MinVal)


		# Create some arbitrary data over a wide range of the data type. This
		# creates evenly spaced data over a range straddling the mid point of the data.
		midpoint = (MaxInt + MinInt) // 2
		startval = (midpoint + MinInt) // 2
		endval = (midpoint + MaxInt) // 2
		stepval = (MaxInt - MinInt) // 100

		halfrangeinc = list(range(startval, endval, stepval))
		halfrangedec = list(range(endval, startval, -stepval))

		gendata = list(itertools.chain.from_iterable(zip(halfrangeinc, halfrangedec)))
		incdata = halfrangeinc
		decdata = halfrangedec
		maxvaldata = list(itertools.chain(halfrangeinc, [MaxVal], halfrangedec))
		minvaldata = list((itertools.chain(halfrangeinc, [MinVal], halfrangedec)))


		# Test arrays.
		self.gentest = array.array('%(typecode)s', [x for x,y in zip(itertools.cycle(gendata), range(arraylength))])
		self.inctest = array.array('%(typecode)s', [x for x,y in zip(itertools.cycle(incdata), range(arraylength))])
		self.dectest = array.array('%(typecode)s', [x for x,y in zip(itertools.cycle(decdata), range(arraylength))])
		self.maxvaltest = array.array('%(typecode)s', [x for x,y in zip(itertools.cycle(maxvaldata), range(arraylength))])
		self.minvaltest = array.array('%(typecode)s', [x for x,y in zip(itertools.cycle(minvaldata), range(arraylength))])


	########################################################
	def test_%(funclabel)s_general_function_01(self):
		"""Test a%(funcname)s  - Array code %(typecode)s. General test %(arrayevenodd)s length array %(simdpresent)s SIMD.
		"""
		result = arrayfunc.a%(funcname)s(self.gentest %(nosimd)s)
		self.assertEqual(result, %(funcname)s(self.gentest))


	########################################################
	def test_%(funclabel)s_general_function_02(self):
		"""Test a%(funcname)s  - Array code %(typecode)s. Test increasing values %(arrayevenodd)s length array %(simdpresent)s SIMD.
		"""
		result = arrayfunc.a%(funcname)s(self.inctest %(nosimd)s)
		self.assertEqual(result, %(funcname)s(self.inctest))


	########################################################
	def test_%(funclabel)s_general_function_03(self):
		"""Test a%(funcname)s  - Array code %(typecode)s. Test decreasing values %(arrayevenodd)s length array %(simdpresent)s SIMD.
		"""
		result = arrayfunc.a%(funcname)s(self.dectest %(nosimd)s)
		self.assertEqual(result, %(funcname)s(self.dectest))


	########################################################
	def test_%(funclabel)s_general_function_04(self):
		"""Test a%(funcname)s  - Array code %(typecode)s. Test finding max for data type %(arrayevenodd)s length array %(simdpresent)s SIMD.
		"""
		result = arrayfunc.a%(funcname)s(self.maxvaltest %(nosimd)s)
		self.assertEqual(result, %(funcname)s(self.maxvaltest))


	########################################################
	def test_%(funclabel)s_general_function_05(self):
		"""Test a%(funcname)s  - Array code %(typecode)s. Test finding value from array that contains min for data type %(arrayevenodd)s length array %(simdpresent)s SIMD.
		"""
		result = arrayfunc.a%(funcname)s(self.minvaltest %(nosimd)s)
		self.assertEqual(result, %(funcname)s(self.minvaltest))


	########################################################
	def test_%(funclabel)s_general_function_06(self):
		"""Test a%(funcname)s  - Array code %(typecode)s. Test optional maxlen parameter %(arrayevenodd)s length array %(simdpresent)s SIMD.
		"""
		result = arrayfunc.a%(funcname)s(self.maxvaltest, maxlen=5 %(nosimd)s)
		self.assertEqual(result, %(funcname)s(self.maxvaltest[:5]))



##############################################################################

'''


# ==============================================================================


# The basic template for testing each array type for parameter errors.
op_template_params = '''

##############################################################################
class %(funclabel)s_parameter_%(arrayevenodd)s_arraysize_%(simdpresent)s_simd_%(typecode)s(unittest.TestCase):
	"""Test %(funclabel)s for basic parameter tests.
	op_template_params
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""

		# We use a template to generate this code, so the following
		# compare is inserted into the template to generate code which
		# spills over past the SIMD handler.
		if '%(arrayevenodd)s' == 'odd':
			arrayextension = 5
		else:
			arrayextension = 0

		arraylength = 96 + arrayextension


		MaxVal = arrayfunc.arraylimits.%(typecode)s_max
		MinVal = arrayfunc.arraylimits.%(typecode)s_min

		self.gentest = array.array('%(typecode)s', [MaxVal // 2] * arraylength)


	########################################################
	def test_%(funclabel)s_param_function_01(self):
		"""Test a%(funcname)s  - Array code %(typecode)s. Test invalid parameter type %(arrayevenodd)s length array %(simdpresent)s SIMD.
		"""
		with self.assertRaises(TypeError):
			result = arrayfunc.a%(funcname)s(1 %(nosimd)s)

		# Check that the exception raised corresponds to the native Python behaviour.
		with self.assertRaises(TypeError):
			result = %(funcname)s(1)


	########################################################
	def test_%(funclabel)s_param_function_02(self):
		"""Test a%(funcname)s  - Array code %(typecode)s. Test missing parameter %(arrayevenodd)s length array %(simdpresent)s SIMD.
		"""
		with self.assertRaises(TypeError):
			result = arrayfunc.a%(funcname)s()

		# Check that the exception raised corresponds to the native Python behaviour.
		with self.assertRaises(TypeError):
			result = %(funcname)s()


	########################################################
	def test_%(funclabel)s_param_function_03(self):
		"""Test a%(funcname)s  - Array code %(typecode)s. Test excess parameters %(arrayevenodd)s length array %(simdpresent)s SIMD.
		"""
		with self.assertRaises(TypeError):
			result = arrayfunc.a%(funcname)s(self.gentest, 5, 2, 2 %(nosimd)s)

		# Check that the exception raised corresponds to the native Python behaviour.
		with self.assertRaises(TypeError):
			result = %(funcname)s(self.gentest, 2)


	########################################################
	def test_%(funclabel)s_param_function_04(self):
		"""Test a%(funcname)s  - Array code %(typecode)s. Test invalid keyword parameter %(arrayevenodd)s length array %(simdpresent)s SIMD.
		"""
		with self.assertRaises(TypeError):
			result = arrayfunc.a%(funcname)s(self.gentest, xxxx=5 %(nosimd)s)

		# Check that the exception raised corresponds to the native Python behaviour.
		with self.assertRaises(TypeError):
			result = %(funcname)s(self.gentest, xxxx=5)


##############################################################################

'''

# ==============================================================================



# The basic template for testing floating point arrays with nan, inf -inf.
nonfinite_template = '''
##############################################################################
class %(funclabel)s_nonfinite_%(rotplaces)s_%(arrayevenodd)s_arraysize_%(simdpresent)s_simd_%(typecode)s(unittest.TestCase):
	"""Test with floating point nan, inf -inf.
	nonfinite_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# We use a template to generate this code, so the following
		# compare is inserted into the template to generate code which
		# spills over past the SIMD handler.
		if '%(arrayevenodd)s' == 'odd':
			arrayextension = 5
		else:
			arrayextension = 0

		arraylength = 96 + arrayextension

		MaxVal = arrayfunc.arraylimits.%(typecode)s_max
		MinVal = arrayfunc.arraylimits.%(typecode)s_min

		# Create some test data containing a mixture of values.
		halfrangedata = list(range(int(MinVal / 2), int(MaxVal / 2), int(MaxVal) - int(MinVal) // 100))

		nanvaldatabase = list(itertools.chain(halfrangedata, [math.nan, -10.0, MaxVal, 10.0, MinVal], halfrangedata))
		infvaldatabase = list(itertools.chain(halfrangedata, [math.inf, -10.0, MaxVal, 10.0, MinVal], halfrangedata))
		ninfvaldatabase = list(itertools.chain(halfrangedata, [-math.inf, -10.0, MaxVal, 10.0, MinVal], halfrangedata))
		mixedvaldatabase = list(itertools.chain(halfrangedata, [math.inf, -math.inf, -10.0, MaxVal, 10.0, MinVal], halfrangedata))


		# Rotate the values in place in order to create different combinations. 
		# This is being generated through a template to allow us to create 
		# different combinations to help test the effects of having the
		# special values in various locations. This is primarily of use
		# for the SIMD tests which do operations in parallel.
		rotplaces = %(rotplaces)s
		nanvaldata = nanvaldatabase[rotplaces:] + nanvaldatabase[:rotplaces]
		infvaldata = infvaldatabase[rotplaces:] + infvaldatabase[:rotplaces]
		ninfvaldata = ninfvaldatabase[rotplaces:] + ninfvaldatabase[:rotplaces]
		mixedvaldata = mixedvaldatabase[rotplaces:] + mixedvaldatabase[:rotplaces]

		# Now create the arrays used in the tests.
		self.data_nan = array.array('%(typecode)s', [x for x,y in zip(itertools.cycle(nanvaldata), range(arraylength))])
		self.data_inf = array.array('%(typecode)s', [x for x,y in zip(itertools.cycle(infvaldata), range(arraylength))])
		self.data_ninf = array.array('%(typecode)s', [x for x,y in zip(itertools.cycle(ninfvaldata), range(arraylength))])
		self.data_mixed = array.array('%(typecode)s', [x for x,y in zip(itertools.cycle(mixedvaldata), range(arraylength))])



	########################################################
	def test_%(funclabel)s_nonfinite_nan_01(self):
		"""Test a%(funcname)s  - Array code %(typecode)s. Test NaN data with  %(arrayevenodd)s length array data shifted %(rotplaces)s %(simdpresent)s SIMD.
		"""
		result = arrayfunc.a%(funcname)s(self.data_nan %(nosimd)s)
		result2 = %(funcname)s(self.data_nan)
		# We don't actually test the result as there is no meaningful order
		# comparison with NaN. 


	########################################################
	def test_%(funclabel)s_nonfinite_inf_02(self):
		"""Test a%(funcname)s  - Array code %(typecode)s. Test Inf data with  %(arrayevenodd)s length array data shifted %(rotplaces)s %(simdpresent)s SIMD.
		"""
		result = arrayfunc.a%(funcname)s(self.data_inf %(nosimd)s)
		self.assertEqual(result, %(funcname)s(self.data_inf))


	########################################################
	def test_%(funclabel)s_nonfinite_ninf_03(self):
		"""Test a%(funcname)s  - Array code %(typecode)s. Test Negative Inf data with  %(arrayevenodd)s length array data shifted %(rotplaces)s %(simdpresent)s SIMD.
		"""
		result = arrayfunc.a%(funcname)s(self.data_ninf %(nosimd)s)
		self.assertEqual(result, %(funcname)s(self.data_ninf))


	########################################################
	def test_%(funclabel)s_nonfinite_mixed_04(self):
		"""Test a%(funcname)s  - Array code %(typecode)s. Test mixed non-finite data with  %(arrayevenodd)s length array data shifted %(rotplaces)s %(simdpresent)s SIMD.
		"""
		# The mixed test does not include NaN, as there is no meaningful order
		# comparison with NaN. 
		result = arrayfunc.a%(funcname)s(self.data_mixed %(nosimd)s)
		self.assertEqual(result, %(funcname)s(self.data_mixed))



##############################################################################
'''



# ==============================================================================

# The functions which are implemented by this program.
completefuncnames = ('amax', 'amin')


# The name of the function without the leading 'a'.
optype = {'amax' : 'max', 
			'amin' : 'min', 
}


# ==============================================================================

# This is used to generate test template data for tests.
def gentestdata(funcname):
	""" Generate test template data for tests.
	funcname (string): - The name of the function.
	Returns: (list) - A list of dictionaries containing the keys and
		values to generate individual test functions.
	"""

	# These are the different test values we will combine in various ways.
	arraycode = [('typecode', x) for x in codegen_common.arraycodes]
	hassimd = (('simdpresent', 'with'), ('simdpresent', 'without'))
	arraylen = (('arrayevenodd', 'even'), ('arrayevenodd', 'odd'))

	# The product function produces all possible combinations.
	combos = list(itertools.product(arraycode, hassimd, arraylen))


	# Convert the data into a list of dictionaries.
	testdata = [dict(x) for x in combos]

	nosimd = {'with' : '', 'without' : ', nosimd=True'}

	# Add in the data that doesn't change.
	for x in testdata:
		x['nosimd'] = nosimd[x['simdpresent']]
		x['funclabel'] = funcname
		x['funcname'] = optype[funcname]

	return testdata


# ==============================================================================

# This is used to generate test template data for non-finite tests.
def gennonfinitetestdata(funcname):
	""" Generate test template data for non-finite tests.
	funcname (string): - The name of the function.
	Returns: (list) - A list of dictionaries containing the keys and
		values to generate individual test functions.
	"""

	# These are the different test values we will combine in various ways.
	arraycode = [('typecode', x) for x in codegen_common.floatarrays]
	hassimd = (('simdpresent', 'with'), ('simdpresent', 'without'))
	arraylen = (('arrayevenodd', 'even'), ('arrayevenodd', 'odd'))
	datarot = [('rotplaces', x) for x in range(5)]

	# The product function produces all possible combinations.
	combos = list(itertools.product(arraycode, hassimd, arraylen, datarot))


	# Convert the data into a list of dictionaries.
	testdata = [dict(x) for x in combos]

	nosimd = {'with' : '', 'without' : ', nosimd=True'}

	# Add in the data that doesn't change.
	for x in testdata:
		x['nosimd'] = nosimd[x['simdpresent']]
		x['funclabel'] = funcname
		x['funcname'] = optype[funcname]

	return testdata

# ==============================================================================

# This defines the module name.
modulename = 'arrayfunc'
# Import the array module for testing.
arrayimport = 'import array'


for funcname in completefuncnames:


	# Data for the copyright header files.
	headerdate = codegen_common.FormatHeaderData('test_%s' % funcname, '11-Jun-2014', funcname)

	# Add additional header data.
	headerdate['modulename'] = modulename
	headerdate['arrayimport'] = arrayimport


	with open('test_%s.py' % funcname, 'w') as f:
		# The copyright header.
		f.write(codegen_common.HeaderTemplate % headerdate)


		# Output the generated code for basic operator tests.
		for datarec in gentestdata(funcname):
			f.write(op_template_general % datarec)
			f.write(op_template_params % datarec)


		# Output the generated code for non-finite data tests.
		for datarec in gennonfinitetestdata(funcname):
			f.write(nonfinite_template % datarec)


		# End of the tests.
		f.write(codegen_common.testendtemplate % {'funcname' : funcname, 'testprefix' : 'af'})


# ==============================================================================
